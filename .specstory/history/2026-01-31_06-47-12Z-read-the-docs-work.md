<!-- Generated by SpecStory, Markdown v2.1.0 -->

# 2026-01-31 06:47:45Z

<!-- Claude Code Session f573d36e-de07-4df4-a6a5-dc9519d8c711 (2026-01-31 06:47:45Z) -->

_**User (2026-01-31 06:47:45Z)**_

read the docs work cli errors file. how does it handle the non enum erroes ? suggest if t is good. what are thee best strategies to handle that ?? 

---

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:48:18Z)**_

<think><details><summary>Thought Process</summary>
The user is asking me to:
1. Read the docs/work/cli-errors file (likely `docs/work/2025-10-31-010-config-system.md` or something similar based on git status)
2. Understand how it handles non-enum errors
3. Evaluate if the approach is good
4. Suggest best strategies for handling non-enum errors

Let me first look for the CLI errors work document. Based on the git status, I can see there are some work files. Let me search for it.
</details></think>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:48:18Z)**_

I'll read the CLI errors work document to analyze the non-enum error handling approach.

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:48:18Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 pattern `docs/work/*cli*error*.md`
```
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2026-01-31-cli-error-handling.md
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2026-01-31-cli-error-handling-iteration-1.md
```
</details></tool-use>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:48:18Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 pattern `docs/work/*.md`
```
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2025-10-30-design.md
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2025-11-01-commands-ready.md
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2025-11-01-commands-stats.md
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2025-10-31-004918-task-ulid-lww-sync-plan.md
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2025-11-01-flow.md
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2025-11-01-spec-flow-002.md
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2025-11-01-006-codeplan.md
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2025-11-01-007-sync-command-impl.md
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2025-11-01-prefix-for-issue-codeplan.md
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2025-11-03-spec-flow-003.md
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2025-10-31-commands-show.md
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2025-10-31-001-task-beads-gitignore-issue-notes.md
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2025-10-31-008-commands-ready-codeplan.md
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2025-10-31-labels.md
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2025-10-31-blob-plan.md
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2025-10-31-bulk-issues.md
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2025-10-31-010-config-system.md
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2026-01-31-cli-error-handling.md
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2026-01-31-natural-agent-interface-implementation.md
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2026-01-31-cli-error-handling-iteration-1.md
```
</details></tool-use>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:48:22Z)**_

<think><details><summary>Thought Process</summary>
Found the CLI error handling docs. Let me read both to understand the approach.
</details></think>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:48:22Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./docs/work/2026-01-31-cli-error-handling-iteration-1.md`
```
     1→# CLI Error Handling - Iteration 1
     2→
     3→## Summary
     4→
     5→Implemented clap `ValueEnum` integration for automatic validation and helpful error messages in the beads CLI.
     6→
     7→## Changes Made
     8→
     9→### 1. Updated `cli/enums.rs` with Custom ValueEnum Implementation
    10→
    11→- Implemented `clap::ValueEnum` trait manually for `Priority`, `Kind`, and `Status` enums
    12→- Added case-insensitive matching via aliases (e.g., "HIGH", "High", "high" all work)
    13→- Added numeric aliases for priority (0, 1, 2, 3 map to low, medium, high, urgent)
    14→- Added multiple format aliases for status (in-progress, in_progress, inprogress, etc.)
    15→
    16→### 2. Updated `main.rs` CLI Arguments
    17→
    18→- Changed `IssueCommand::Create`, `Update`, `List` to use typed enums (`Priority`, `Kind`, `Status`)
    19→- Changed `Commands::Search` to use typed enums
    20→- Added `#[arg(value_enum)]` attribute to enable clap validation
    21→- Added `#[command(hide = true)]` to deprecated commands (Create, Show, List, Update)
    22→
    23→### 3. Updated Command Handlers
    24→
    25→- `commands/issue/create.rs`: Changed priority param from `Option<String>` to `Option<u32>`
    26→- `commands/issue/update.rs`: Changed priority/status/kind to pre-validated types
    27→- `commands/issue/list.rs`: Changed filter params to use pre-validated types
    28→- Removed manual validation logic (now handled by clap)
    29→
    30→### 4. Removed `cli/errors.rs`
    31→
    32→- Deleted the manual error message helpers (no longer needed)
    33→- Removed `pub mod errors;` from `cli/mod.rs`
    34→
    35→## Test Results
    36→
    37→### ✅ Working
    38→
    39→```bash
    40→# Help shows possible values
    41→$ beads issue create --help
    42→      --kind <KIND>
    43→          Issue kind: bug, feature, refactor, docs, chore, task
    44→          Possible values:
    45→          - bug:      Bug fix
    46→          - feature:  New feature
    47→          ...
    48→
    49→# Case-insensitive matching
    50→$ beads issue create --title "Test" --priority HIGH
    51→Created issue bd-095
    52→
    53→$ beads issue create --title "Test 2" --priority 2 --kind BUG
    54→Created issue bd-096
    55→
    56→# Status update with different formats
    57→$ beads issue update bd-095 --status CLOSED
    58→Updated issue bd-095
    59→
    60→# Invalid values show helpful error
    61→$ beads issue create --title "Test" --priority critical
    62→error: invalid value 'critical' for '--priority <PRIORITY>'
    63→  [possible values: low, medium, high, urgent]
    64→```
    65→
    66→### ⚠️ Known Issues
    67→
    68→1. **"No updates specified" error** - When running `beads issue update <id>` without flags, the error message doesn't list available options:
    69→   ```
    70→   $ beads issue update bd-095
    71→   Error: No updates specified
    72→   ```
    73→   Should be: `"No updates specified. Use: --title, --description, --kind, --priority, --status, --add-label, --remove-label"`
    74→
    75→2. **Deprecated commands hidden** - Old commands still work but are hidden from help:
    76→   ```
    77→   $ beads --help  # No longer shows create, show, list, update
    78→   ```
    79→
    80→## Next Steps (Iteration 2)
    81→
    82→1. Improve non-enum error messages:
    83→   - "No updates specified" → list available flags
    84→   - "Invalid JSON data" → show expected format hint
    85→   - Missing repo → suggest `beads init`
    86→
    87→2. Test edge cases:
    88→   - Numeric priority 0-3
    89→   - Mixed case variations
    90→   - Invalid enum values
    91→
    92→3. Consider adding integration tests with `assert_cmd`
    93→
```
</details></tool-use>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:48:23Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./docs/work/2026-01-31-cli-error-handling.md`
```
     1→# CLI Error Handling with Clap Integration
     2→
     3→## Goal
     4→Helpful, context-aware error messages in the beads CLI. Typed enums at the clap layer with automatic validation, possible-value hints, and case-insensitive matching — while keeping numeric priority backward compat and preserving the events.jsonl format.
     5→
     6→## Decisions (Resolved)
     7→- Validate at clap layer (not business logic)
     8→- Case-insensitive matching
     9→- Flags override `--data` JSON
    10→- `beads issue <action>` is the canonical path; old top-level commands get `#[command(hide = true)]`
    11→- Priority accepts both names (`high`) and numbers (`2`) — stored as u32 internally
    12→- events.jsonl format unchanged: priority=u32, kind=string, status=string
    13→
    14→---
    15→
    16→## Architecture: Old Path vs New Path
    17→
    18→### NEW PATH (canonical) — `beads issue <action>`
    19→| File | Purpose |
    20→|------|---------|
    21→| `crates/beads/src/cli/enums.rs` | `Priority`, `Kind`, `Status` with `ValueEnum` + custom `from_str` for numeric compat |
    22→| `crates/beads/src/cli/mod.rs` | Re-exports |
    23→| `crates/beads/src/commands/issue/create.rs` | Issue create using typed enums |
    24→| `crates/beads/src/commands/issue/update.rs` | Issue update using typed enums |
    25→| `crates/beads/src/commands/issue/list.rs` | Issue list with typed filters |
    26→| `crates/beads/src/commands/issue/show.rs` | Issue show |
    27→| `crates/beads/src/commands/issue/mod.rs` | Subcommand routing |
    28→
    29→### OLD PATH (deprecated, hidden) — `beads create`, `beads update`, etc.
    30→| File | Purpose | Status |
    31→|------|---------|--------|
    32→| `crates/beads/src/commands/create.rs` | Old create (requires `--data` JSON) | DEPRECATED — hide, delete in v2 |
    33→| `crates/beads/src/commands/update.rs` | Old update (`--priority` as u32) | DEPRECATED — hide, delete in v2 |
    34→| `crates/beads/src/commands/list.rs` | Old list (no kind/priority filters) | DEPRECATED — hide, delete in v2 |
    35→| `crates/beads/src/commands/show.rs` | Old show | DEPRECATED — hide, delete in v2 |
    36→
    37→### SHARED (both paths use)
    38→| File | Purpose |
    39→|------|---------|
    40→| `crates/beads/src/commands/search.rs` | Search — migrate to typed enums |
    41→| `crates/beads/src/commands/ready.rs` | Ready — no enum args, unchanged |
    42→| `crates/beads/src/commands/sync.rs` | Sync — no enum args, unchanged |
    43→| `crates/beads/src/commands/delete.rs` | Delete — no enum args, unchanged |
    44→| `crates/beads/src/commands/dep.rs` | Dependencies — no enum args, unchanged |
    45→| `crates/beads/src/commands/label.rs` | Labels — no enum args, unchanged |
    46→| `crates/beads/src/commands/doc.rs` | Documents — no enum args, unchanged |
    47→
    48→### TO DELETE (after typed enums land)
    49→| File | Reason |
    50→|------|--------|
    51→| `crates/beads/src/cli/errors.rs` | Clap handles error messages natively with ValueEnum |
    52→
    53→---
    54→
    55→## events.jsonl Format (UNCHANGED)
    56→
    57→Priority maps internally to u32 before hitting the core library. The event format is stable:
    58→
    59→```json
    60→{"event_id":"...","ts":"...","op":"create","id":"bd-001","actor":"...","data":{"title":"...","kind":"task","priority":1,"status":"open"}}
    61→{"event_id":"...","ts":"...","op":"update","id":"bd-001","actor":"...","data":{"priority":3,"status":"in_progress"}}
    62→```
    63→
    64→- `priority`: always u32 (0=low, 1=medium, 2=high, 3=urgent)
    65→- `kind`: always string ("bug", "feature", "refactor", "docs", "chore", "task")
    66→- `status`: always string ("open", "in_progress", "review", "closed", "deleted")
    67→
    68→Old events remain parsable. New CLI just changes how users *input* values, not how they're *stored*.
    69→
    70→---
    71→
    72→## Implementation Plan
    73→
    74→### Step 1: Rework `cli/enums.rs` with `ValueEnum` + numeric compat
    75→
    76→Replace hand-rolled parsing with clap's `ValueEnum` derive. Add custom `value_parser` for Priority that accepts both names and numbers.
    77→
    78→```rust
    79→#[derive(clap::ValueEnum, Clone, Copy)]
    80→pub enum Kind {
    81→    Bug, Feature, Refactor, Docs, Chore, Task,
    82→}
    83→
    84→#[derive(clap::ValueEnum, Clone, Copy)]
    85→pub enum Status {
    86→    Open,
    87→    #[value(alias = "in-progress", alias = "inprogress")]
    88→    InProgress,
    89→    Review, Closed,
    90→}
    91→
    92→// Priority needs custom parser for numeric backward compat
    93→#[derive(Clone, Copy)]
    94→pub enum Priority {
    95→    Low = 0, Medium = 1, High = 2, Urgent = 3,
    96→}
    97→
    98→// Custom value_parser that accepts "high" OR "2"
    99→pub fn parse_priority(s: &str) -> Result<Priority, String> {
   100→    match s.to_lowercase().as_str() {
   101→        "low" | "0" => Ok(Priority::Low),
   102→        "medium" | "1" => Ok(Priority::Medium),
   103→        "high" | "2" => Ok(Priority::High),
   104→        "urgent" | "3" => Ok(Priority::Urgent),
   105→        _ => Err(format!(
   106→            "invalid priority '{}'. Valid: low (0), medium (1), high (2), urgent (3)",
   107→            s
   108→        )),
   109→    }
   110→}
   111→
   112→impl Priority {
   113→    pub fn as_u32(self) -> u32 { self as u32 }
   114→}
   115→impl Kind {
   116→    pub fn as_str(&self) -> &'static str { /* match */ }
   117→}
   118→impl Status {
   119→    pub fn as_str(&self) -> &'static str { /* match */ }
   120→}
   121→```
   122→
   123→### Step 2: Update `IssueCommand` in `main.rs` to use typed enums
   124→
   125→```rust
   126→enum IssueCommand {
   127→    Create {
   128→        #[arg(short, long)]
   129→        title: String,
   130→        #[arg(long)]
   131→        description: Option<String>,
   132→        #[arg(long, value_enum)]
   133→        kind: Option<Kind>,                    // was Option<String>
   134→        #[arg(long, value_parser = parse_priority)]
   135→        priority: Option<Priority>,            // was Option<String>
   136→        // ... rest unchanged
   137→    },
   138→    Update {
   139→        // ...
   140→        #[arg(long, value_enum)]
   141→        kind: Option<Kind>,
   142→        #[arg(long, value_parser = parse_priority)]
   143→        priority: Option<Priority>,
   144→        #[arg(long, value_enum)]
   145→        status: Option<Status>,                // was Option<String>
   146→        // ...
   147→    },
   148→    List {
   149→        #[arg(long, value_enum)]
   150→        status: Option<Status>,
   151→        #[arg(long, value_parser = parse_priority)]
   152→        priority: Option<Priority>,            // was Option<String>
   153→        #[arg(long, value_enum)]
   154→        kind: Option<Kind>,
   155→        // ...
   156→    },
   157→}
   158→```
   159→
   160→### Step 3: Hide old commands in `main.rs`
   161→
   162→```rust
   163→#[derive(Subcommand)]
   164→enum Commands {
   165→    Init { ... },
   166→
   167→    #[command(hide = true)]  // deprecated
   168→    Create { ... },
   169→
   170→    #[command(hide = true)]  // deprecated
   171→    Show { ... },
   172→
   173→    #[command(hide = true)]  // deprecated
   174→    List { ... },
   175→
   176→    #[command(hide = true)]  // deprecated
   177→    Update { ... },
   178→
   179→    // ... Sync, Search, Ready, Dep, Label, Doc, Delete stay visible
   180→    // Issue stays visible (canonical path)
   181→}
   182→```
   183→
   184→### Step 4: Update new-path command handlers
   185→
   186→`commands/issue/create.rs`:
   187→- Change signature: `priority: Option<Priority>` instead of `Option<String>`
   188→- Remove manual `Priority::from_str()` call — already parsed by clap
   189→- `final_priority = priority.map(|p| p.as_u32()).or(json_priority).unwrap_or(1)`
   190→
   191→`commands/issue/update.rs`:
   192→- Same pattern — remove manual parsing, use `.as_u32()`, `.as_str()`
   193→- Delete the `invalid_enum_error_short` call — clap rejects bad values before we get here
   194→
   195→`commands/issue/list.rs`:
   196→- Accept typed `Option<Status>`, `Option<Priority>`, `Option<Kind>`
   197→- Convert to strings/u32 when passing to core library
   198→
   199→### Step 5: Migrate `search` command to typed enums
   200→
   201→`commands/search.rs` currently uses `Option<String>` for kind/status and `Option<u32>` for priority. Update to use the typed enums for consistent UX across all commands.
   202→
   203→### Step 6: Delete `cli/errors.rs`
   204→
   205→No longer needed — clap generates error messages automatically. Remove the file and the `pub mod errors;` from `cli/mod.rs`.
   206→
   207→### Step 7: Improve non-enum error messages
   208→
   209→In command handlers, improve remaining hand-written errors:
   210→- "No updates specified" → list available flags
   211→- "Invalid JSON data" → show expected format hint
   212→- Missing repo → suggest `beads init`
   213→
   214→### Step 8: Add integration tests
   215→
   216→Add `assert_cmd` dev-dependency. Test actual binary output:
   217→- Invalid priority → shows valid values
   218→- Invalid kind → shows valid values
   219→- `--help` shows possible values inline
   220→- Numeric priority still works (`--priority 2`)
   221→- Case insensitive (`--priority HIGH`)
   222→- Old hidden commands still work (backward compat)
   223→
   224→---
   225→
   226→## What This Gives Us
   227→
   228→**Before:**
   229→```
   230→$ beads issue create --title "test" --priority critical
   231→# silently defaults to medium, no error
   232→```
   233→
   234→**After:**
   235→```
   236→$ beads issue create --title "test" --priority critical
   237→error: invalid priority 'critical'. Valid: low (0), medium (1), high (2), urgent (3)
   238→
   239→$ beads issue create --help
   240→  --priority <PRIORITY>  [possible values: low, medium, high, urgent]
   241→  --kind <KIND>          [possible values: bug, feature, refactor, docs, chore, task]
   242→```
   243→
   244→Old commands still work but are hidden from `--help`:
   245→```
   246→$ beads create --title "test" --data '{"priority":2}'  # still works
   247→$ beads --help  # doesn't show create/update/list/show
   248→```
   249→
```
</details></tool-use>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:48:26Z)**_

<think><details><summary>Thought Process</summary>
Now let me check the current error.rs implementation to see how non-enum errors are currently handled.
</details></think>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:48:27Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./crates/beads-core/src/error.rs`
```
     1→use thiserror::Error;
     2→
     3→#[derive(Debug, Error)]
     4→pub enum BeadsError {
     5→    #[error("io error: {0}")]
     6→    Io(#[from] std::io::Error),
     7→    #[error("database error: {0}")]
     8→    Db(#[from] rusqlite::Error),
     9→    #[error("serialization error: {0}")]
    10→    Serde(#[from] serde_json::Error),
    11→    #[error("ulid decode error: {0}")]
    12→    UlidDecode(#[from] ulid::DecodeError),
    13→    #[error("beads repository already initialized")]
    14→    AlreadyInitialized,
    15→    #[error("beads repository not found. Run 'beads init --prefix <prefix>' to create one.")]
    16→    RepoNotFound,
    17→    #[error("missing repository configuration: {0}")]
    18→    MissingConfig(&'static str),
    19→    #[error("update requires at least one field")]
    20→    EmptyUpdate,
    21→    #[error("blob not found: {0}")]
    22→    BlobNotFound(String),
    23→    #[error("invalid hash: {0}")]
    24→    InvalidHash(String),
    25→    #[error("{0}")]
    26→    Custom(String),
    27→}
    28→
    29→pub type Result<T> = std::result::Result<T, BeadsError>;
    30→
```
</details></tool-use>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:48:29Z)**_

<think><details><summary>Thought Process</summary>
Now let me check how non-enum errors are being used in the CLI command handlers.
</details></think>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:48:30Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./crates/beads/src/commands/issue/create.rs`
```
     1→//! Issue create command with natural CLI interface
     2→//!
     3→//! Supports both individual flags (--title, --priority, etc.) and
     4→//! JSON --data flag for backward compatibility. Individual flags override JSON values.
     5→
     6→use std::fs;
     7→
     8→use anyhow::{anyhow, Result};
     9→use beads_core::{
    10→    add_document_to_issue, add_label_to_issue, create_issue_with_data, repo::BeadsRepo,
    11→    update_issue, IssueUpdate,
    12→};
    13→
    14→/// Run the issue create command
    15→///
    16→/// # Arguments
    17→/// * `repo` - The beads repository
    18→/// * `title` - Issue title (required)
    19→/// * `description` - Issue description (optional)
    20→/// * `kind` - Issue kind (optional, defaults to "task")
    21→/// * `priority` - Priority as u32 (optional, defaults to 1/medium)
    22→/// * `label` - Comma-separated labels to add (optional)
    23→/// * `depends_on` - Dependencies (can be used multiple times)
    24→/// * `doc` - Documents in "name:path" format (can be used multiple times)
    25→/// * `data` - JSON data for backward compatibility (optional, flags override this)
    26→pub fn run(
    27→    repo: BeadsRepo,
    28→    title: &str,
    29→    description: Option<String>,
    30→    kind: Option<String>,
    31→    priority: Option<u32>,
    32→    label: Option<String>,
    33→    depends_on: Vec<String>,
    34→    doc: Vec<String>,
    35→    data: Option<String>,
    36→) -> Result<()> {
    37→    // 1. Validate title
    38→    if title.trim().is_empty() {
    39→        return Err(anyhow!("Title is required and cannot be empty"));
    40→    }
    41→
    42→    // 2. Parse JSON --data if provided
    43→    let (json_kind, json_priority, json_desc): (Option<String>, Option<u32>, Option<String>) =
    44→        if let Some(data_str) = &data {
    45→            let parsed = serde_json::from_str::<serde_json::Value>(data_str)
    46→                .map_err(|e| anyhow!("Invalid JSON data: {}\n\nExpected format: '{{\"description\":\"...\",\"priority\":1,\"kind\":\"bug\"}}'", e))?;
    47→            let kind = parsed.get("kind").and_then(|v| v.as_str()).map(|s| s.to_string());
    48→            let priority = parsed.get("priority").and_then(|v| v.as_u64()).map(|p| p as u32);
    49→            let desc = parsed
    50→                .get("description")
    51→                .and_then(|v| v.as_str())
    52→                .map(|s| s.to_string());
    53→            (kind, priority, desc)
    54→        } else {
    55→            (None, None, None)
    56→        };
    57→
    58→    // 3. Merge flags (flags override JSON)
    59→    let final_kind = kind.or(json_kind).unwrap_or_else(|| "task".to_string());
    60→
    61→    // Priority is now pre-validated by clap as u32
    62→    let final_priority = priority.or(json_priority).unwrap_or(1); // default to "medium"
    63→
    64→    let final_description = description.or(json_desc);
    65→
    66→    // 4. Create issue
    67→    let data_json: Option<serde_json::Value> = data
    68→        .as_ref()
    69→        .map(|s| serde_json::from_str(s).ok())
    70→        .flatten();
    71→
    72→    let event = create_issue_with_data(
    73→        &repo,
    74→        title,
    75→        &final_kind,
    76→        final_priority,
    77→        depends_on,
    78→        data_json,
    79→    )?;
    80→
    81→    println!("Created issue {}", event.id);
    82→
    83→    // 5. Update description if provided
    84→    if let Some(desc) = final_description {
    85→        let mut update = IssueUpdate::default();
    86→        update.description = Some(desc);
    87→        update_issue(&repo, &event.id, update)?;
    88→    }
    89→
    90→    // 6. Add labels
    91→    if let Some(label_str) = label {
    92→        let label_names: Vec<&str> = label_str.split(',').map(|s| s.trim()).collect();
    93→        for label_name in label_names {
    94→            if !label_name.is_empty() {
    95→                match add_label_to_issue(&repo, &event.id, label_name) {
    96→                    Ok(_) => println!("Added label '{}'", label_name),
    97→                    Err(e) => eprintln!("Failed to add label '{}': {}", label_name, e),
    98→                }
    99→            }
   100→        }
   101→    }
   102→
   103→    // 7. Attach documents
   104→    for doc_spec in doc {
   105→        let parts: Vec<&str> = doc_spec.splitn(2, ':').collect();
   106→        if parts.len() != 2 {
   107→            eprintln!("Invalid doc format '{}'. Expected 'name:path'", doc_spec);
   108→            continue;
   109→        }
   110→
   111→        let doc_name = parts[0];
   112→        let file_path = parts[1];
   113→
   114→        match fs::read(file_path) {
   115→            Ok(content) => {
   116→                match add_document_to_issue(&repo, &event.id, doc_name, &content) {
   117→                    Ok(_) => println!("Attached '{}' to {}", doc_name, event.id),
   118→                    Err(e) => eprintln!("Failed to attach '{}': {}", doc_name, e),
   119→                }
   120→            }
   121→            Err(e) => eprintln!("Failed to read file '{}': {}", file_path, e),
   122→        }
   123→    }
   124→
   125→    Ok(())
   126→}
   127→
```
</details></tool-use>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:48:31Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./crates/beads/src/commands/issue/update.rs`
```
     1→//! Issue update command with natural CLI interface
     2→//!
     3→//! Supports both individual flags and JSON --data flag for backward compatibility.
     4→/// Individual flags override JSON values.
     5→
     6→use anyhow::{anyhow, Result};
     7→use beads_core::{
     8→    add_label_to_issue, remove_label_from_issue, repo::BeadsRepo, update_issue, IssueUpdate,
     9→};
    10→
    11→/// Run the issue update command
    12→///
    13→/// # Arguments
    14→/// * `repo` - The beads repository
    15→/// * `id` - Issue ID to update
    16→/// * `title` - New title (optional)
    17→/// * `description` - New description (optional)
    18→/// * `kind` - New kind (optional)
    19→/// * `priority` - New priority as u32 (optional)
    20→/// * `status` - New status (optional)
    21→/// * `add_label` - Comma-separated labels to add (optional)
    22→/// * `remove_label` - Comma-separated labels to remove (optional)
    23→/// * `data` - JSON data for backward compatibility (optional, flags override this)
    24→pub fn run(
    25→    repo: BeadsRepo,
    26→    id: &str,
    27→    title: Option<String>,
    28→    description: Option<String>,
    29→    kind: Option<String>,
    30→    priority: Option<u32>,
    31→    status: Option<String>,
    32→    add_label: Option<String>,
    33→    remove_label: Option<String>,
    34→    data: Option<String>,
    35→) -> Result<()> {
    36→    let mut update = IssueUpdate::default();
    37→
    38→    // Set direct fields
    39→    update.title = title;
    40→    update.kind = kind;
    41→    update.description = description;
    42→    update.status = status;
    43→
    44→    // Priority is now pre-validated by clap as u32
    45→    update.priority = priority;
    46→
    47→    // Parse JSON --data if provided
    48→    if let Some(data_str) = data {
    49→        let json = serde_json::from_str::<serde_json::Value>(&data_str)
    50→            .map_err(|e| anyhow!("Invalid JSON data: {}\n\nExpected format: '{{\"description\":\"...\",\"priority\":1,\"status\":\"closed\"}}'", e))?;
    51→
    52→        // Apply JSON values only if not already set by flags
    53→        if update.description.is_none() {
    54→            update.description = json
    55→                .get("description")
    56→                .and_then(|v| v.as_str())
    57→                .map(|s| s.to_string());
    58→        }
    59→        if update.design.is_none() {
    60→            update.design = json
    61→                .get("design")
    62→                .and_then(|v| v.as_str())
    63→                .map(|s| s.to_string());
    64→        }
    65→        if update.acceptance_criteria.is_none() {
    66→            update.acceptance_criteria = json
    67→                .get("acceptance_criteria")
    68→                .and_then(|v| v.as_str())
    69→                .map(|s| s.to_string());
    70→        }
    71→        if update.notes.is_none() {
    72→            update.notes = json
    73→                .get("notes")
    74→                .and_then(|v| v.as_str())
    75→                .map(|s| s.to_string());
    76→        }
    77→        update.data = Some(json);
    78→    }
    79→
    80→    // Check if we have any updates to apply
    81→    let has_field_updates = !update.is_empty();
    82→    let has_label_operations = add_label.is_some() || remove_label.is_some();
    83→
    84→    if !has_field_updates && !has_label_operations {
    85→        return Err(anyhow!(
    86→            "No updates specified.\n\nAvailable options:\n  --title <TITLE>\n  --description <DESCRIPTION>\n  --kind <KIND>\n  --priority <PRIORITY>\n  --status <STATUS>\n  --add-label <LABELS>\n  --remove-label <LABELS>\n  --data <JSON>\n\nExample: beads issue update {} --status closed",
    87→            id
    88→        ));
    89→    }
    90→
    91→    // Apply field updates if any
    92→    if has_field_updates {
    93→        let event = update_issue(&repo, id, update)?;
    94→        println!("Updated issue {} via event {}", id, event.event_id);
    95→    }
    96→
    97→    // Handle label operations
    98→    if let Some(labels_str) = add_label {
    99→        let label_names: Vec<&str> = labels_str.split(',').map(|s| s.trim()).collect();
   100→        for label_name in label_names {
   101→            if !label_name.is_empty() {
   102→                match add_label_to_issue(&repo, id, label_name) {
   103→                    Ok(_) => println!("Added label '{}'", label_name),
   104→                    Err(e) => eprintln!("Failed to add label '{}': {}", label_name, e),
   105→                }
   106→            }
   107→        }
   108→    }
   109→
   110→    if let Some(labels_str) = remove_label {
   111→        let label_names: Vec<&str> = labels_str.split(',').map(|s| s.trim()).collect();
   112→        for label_name in label_names {
   113→            if !label_name.is_empty() {
   114→                match remove_label_from_issue(&repo, id, label_name) {
   115→                    Ok(_) => println!("Removed label '{}'", label_name),
   116→                    Err(e) => eprintln!("Failed to remove label '{}': {}", label_name, e),
   117→                }
   118→            }
   119→        }
   120→    }
   121→
   122→    Ok(())
   123→}
   124→
```
</details></tool-use>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:48:38Z)**_

<think><details><summary>Thought Process</summary>
Good, now I have a complete picture. Let me analyze how non-enum errors are handled and suggest best strategies.

Current approach for non-enum errors:
1. **Invalid JSON data** - `create.rs:46` and `update.rs:50` use custom error messages with hints
2. **No updates specified** - `update.rs:85-88` has a good error with all available options listed
3. **Empty title** - `create.rs:39` has a simple error message
4. **Invalid doc format** - `create.rs:107` just logs to stderr
5. **File read errors** - `create.rs:121` logs to stderr

The docs mention in iteration-1.md that the "No updates specified" error was initially too brief but has been improved in the current code (update.rs:85-88).

Let me provide a comprehensive analysis.
</details></think>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:49:04Z)**_

## Analysis: Non-Enum Error Handling

Based on the docs and code, here's how non-enum errors are currently handled:

### Current Approach (Good ✅)

**1. "No updates specified"** (`update.rs:85-88`)
```rust
return Err(anyhow!(
    "No updates specified.\n\nAvailable options:\n  --title <TITLE>\n  --description <DESCRIPTION>\n  --kind <KIND>\n  --priority <PRIORITY>\n  --status <STATUS>\n  --add-label <LABELS>\n  --remove-label <LABELS>\n  --data <JSON>\n\nExample: beads issue update {} --status closed",
    id
));
```
**Status:** ✅ Well-structured w/ actionable options + example

**2. Invalid JSON** (`create.rs:46`, `update.rs:50`)
```rust
.map_err(|e| anyhow!("Invalid JSON data: {}\n\nExpected format: '{{\"description\":\"...\",\"priority\":1,\"kind\":\"bug\"}}'", e))?;
```
**Status:** ✅ Shows parse error + expected format

**3. Empty title** (`create.rs:39`)
```rust
return Err(anyhow!("Title is required and cannot be empty"));
```
**Status:** ⚠️ Clear but could suggest fix

---

## Best Strategies for Non-Enum Errors

### 1. **Contextual Error Messages** (Highest Priority)
Pattern: `Problem → Why → Solution`

```rust
// BAD
Err(anyhow!("No updates specified"))

// GOOD (current)
Err(anyhow!(
    "No updates specified.\n\nAvailable options:\n  --title <TITLE>...\n\nExample: beads issue update {} --status closed",
    id
))
```

### 2. **Actionable Suggestions**
Always include "what to do next"

```rust
// For missing repo
BeadsError::RepoNotFound → "Run 'beads init --prefix <prefix>'"

// For invalid doc format
"Invalid doc format '{}'. Expected 'name:path'\nExample: --doc readme:./README.md"
```

### 3. **Progressive Detail Levels**
```rust
// Brief version (single flag errors)
Err(anyhow!("Title cannot be empty"))

// Detailed version (complex operations)
Err(anyhow!(
    "No updates specified.\n\n\
     Available options:\n  \
     --title, --description, --kind, --priority, --status\n\n\
     Example: beads issue update {} --status closed", 
    id
))
```

### 4. **Error Categories** (already using `BeadsError` well)
```rust
// System errors (auto-derived via #[from])
Io(#[from] std::io::Error)
Db(#[from] rusqlite::Error)

// User errors (explicit messages)
RepoNotFound → actionable hint
EmptyUpdate → show available options
```

### 5. **CLI-Specific Error Context**
Enhance `BeadsError` variants for CLI use:

```rust
// Option A: Add CLI-friendly helpers
impl BeadsError {
    pub fn with_cli_hint(self) -> String {
        match self {
            Self::RepoNotFound => format!("{}\n\nTip: Run 'beads init --prefix bd'", self),
            Self::EmptyUpdate => format!("{}\n\nSee: beads issue update --help", self),
            _ => self.to_string()
        }
    }
}

// Option B: Separate CLI error type
#[derive(Error, Debug)]
pub enum CliError {
    #[error("{0}\n\n{1}")]
    WithHint(BeadsError, &'static str),
    
    #[error(transparent)]
    Core(#[from] BeadsError),
}
```

### 6. **Consistent Formatting**
```
Pattern:
<Error description>

<Context/details if complex>

<Actionable suggestion>
Example: <command>
```

---

## Recommendations

### High Priority
1. ✅ **Keep current "No updates specified" approach** - excellent pattern
2. ✅ **Keep JSON error w/ format hints** - good UX
3. ⚠️ **Enhance file operation errors**:
   ```rust
   // Instead of just eprintln
   Err(e) => return Err(anyhow!(
       "Failed to read file '{}': {}\n\nCheck: File exists and is readable",
       file_path, e
   ))
   ```

### Medium Priority  
4. Add CLI hints wrapper for `BeadsError::RepoNotFound`:
   ```rust
   // In CLI handler
   .map_err(|e| match e {
       BeadsError::RepoNotFound => anyhow!(
           "{}\n\nTip: Initialize with 'beads init --prefix bd'", e
       ),
       _ => e.into()
   })?
   ```

### Low Priority (Future)
5. Integration tests for error messages (`assert_cmd`)
6. Consistent error code system (e.g., `E001: Repository not found`)

---

## Summary

**Current state:** Good foundation. The "No updates specified" error demonstrates the right pattern.

**Best strategy:** **Problem → Context → Solution** format w/ examples, applied consistently across:
- Missing required data → show what's needed + example
- Invalid input → show expected format + valid values  
- System errors → suggest diagnostic steps
- Missing resources → show initialization command

The approach in `update.rs:85-88` should be the **template** for all non-enum errors.

_**Agent - sidechain (2026-01-31 06:49:04Z)**_

[SUGGESTION MODE: Suggest what the user might naturally type next into Claude Code.]

FIRST: Look at the user's recent messages and original request.

Your job is to predict what THEY would type - not what you think they should do.

THE TEST: Would they think "I was just about to type that"?

EXAMPLES:
User asked "fix the bug and run tests", bug is fixed → "run the tests"
After code written → "try it out"
Claude offers options → suggest the one the user would likely pick, based on conversation
Claude asks to continue → "yes" or "go ahead"
Task complete, obvious follow-up → "commit this" or "push it"
After error or misunderstanding → silence (let them assess/correct)

Be specific: "run the tests" beats "continue".

NEVER SUGGEST:
- Evaluative ("looks good", "thanks")
- Questions ("what about...?")
- Claude-voice ("Let me...", "I'll...", "Here's...")
- New ideas they didn't ask about
- Multiple sentences

Stay silent if the next step isn't obvious from what the user said.

Format: 2-12 words, match the user's style. Or nothing.

Reply with ONLY the suggestion, no quotes or explanation.

_**Agent - sidechain (<synthetic> 2026-01-31 06:49:04Z)**_

API Error: 400 {"type":"error","error":{"type":"invalid_request_error","message":"thinking.enabled.budget_tokens: Input should be greater than or equal to 1024"},"request_id":"req_011CXf1WvVip637q7rU6ELS2"}

---

_**User (2026-01-31 06:50:27Z)**_

read thw current impl as well. how does a good library author arrange errors so thst they are very easy to evolve?? 


for example 
Pattern: Problem → Why → Solution                               
  // BAD
  Err(anyhow!("No updates specified"))
                                                                    // GOOD (current)                                                 Err(anyhow!(
      "No updates specified.\n\nAvailable options:\n  --title
  <TITLE>...\n\nExample: beads issue update {} --status closed",
      id                                                            ))

this does not feel easily evolvable. if i change the errors later -> i will have to update strinfs at various places. not ideal??? can we do better ??? 

---

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:50:35Z)**_

<think><details><summary>Thought Process</summary>
Great question! The user is right - hardcoding error messages with formatting scattered across the codebase is not evolvable. Let me analyze the current implementation and suggest better patterns that library authors use.

Key problems with current approach:
1. Error messages hardcoded in command handlers
2. No central error catalog
3. Formatting logic duplicated
4. Can't easily change error format globally
5. Can't add error codes or structured metadata later
6. Testing individual error messages is hard

Let me look at the current error.rs implementation again and suggest better patterns used by mature Rust libraries like:
- rustc (miette for diagnostics)
- cargo (custom error types with codes)
- clap (ValueEnum errors)
- sqlx (error codes + context)

I should suggest:
1. Centralized error definitions
2. Builder pattern for rich errors
3. Error codes/IDs
4. Structured context (not string formatting)
5. Separation of error data from presentation
6. Display trait customization
</details></think>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:50:36Z)**_

You're absolutely right! Current approach is brittle. Let me read the current impl and show how good library authors make errors evolvable.

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:50:37Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./crates/beads-core/src/error.rs`
```
     1→use thiserror::Error;
     2→
     3→#[derive(Debug, Error)]
     4→pub enum BeadsError {
     5→    #[error("io error: {0}")]
     6→    Io(#[from] std::io::Error),
     7→    #[error("database error: {0}")]
     8→    Db(#[from] rusqlite::Error),
     9→    #[error("serialization error: {0}")]
    10→    Serde(#[from] serde_json::Error),
    11→    #[error("ulid decode error: {0}")]
    12→    UlidDecode(#[from] ulid::DecodeError),
    13→    #[error("beads repository already initialized")]
    14→    AlreadyInitialized,
    15→    #[error("beads repository not found. Run 'beads init --prefix <prefix>' to create one.")]
    16→    RepoNotFound,
    17→    #[error("missing repository configuration: {0}")]
    18→    MissingConfig(&'static str),
    19→    #[error("update requires at least one field")]
    20→    EmptyUpdate,
    21→    #[error("blob not found: {0}")]
    22→    BlobNotFound(String),
    23→    #[error("invalid hash: {0}")]
    24→    InvalidHash(String),
    25→    #[error("{0}")]
    26→    Custom(String),
    27→}
    28→
    29→pub type Result<T> = std::result::Result<T, BeadsError>;
    30→
```
</details></tool-use>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:50:39Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `./crates/beads/src/commands` pattern `anyhow!`
```
Found 8 files
crates/beads/src/commands/issue/update.rs
crates/beads/src/commands/issue/create.rs
crates/beads/src/commands/create.rs
crates/beads/src/commands/doc.rs
crates/beads/src/commands/dep.rs
crates/beads/src/commands/show.rs
crates/beads/src/commands/update.rs
crates/beads/src/commands/sync.rs
```
</details></tool-use>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:50:42Z)**_

<think><details><summary>Thought Process</summary>
Let me look at a few examples of how errors are currently used in the codebase to understand the pattern better.
</details></think>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:50:43Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `./crates/beads/src/commands/issue` pattern `anyhow!\(`
```
/home/abhishek/Downloads/experiments/ai-tools/beadify/crates/beads/src/commands/issue/create.rs-38-    if title.trim().is_empty() {
crates/beads/src/commands/issue/create.rs:39:        return Err(anyhow!("Title is required and cannot be empty"));
/home/abhishek/Downloads/experiments/ai-tools/beadify/crates/beads/src/commands/issue/create.rs-40-    }
/home/abhishek/Downloads/experiments/ai-tools/beadify/crates/beads/src/commands/issue/create.rs-41-
/home/abhishek/Downloads/experiments/ai-tools/beadify/crates/beads/src/commands/issue/create.rs-42-    // 2. Parse JSON --data if provided
--
crates/beads/src/commands/issue/create.rs-45-            let parsed = serde_json::from_str::<serde_json::Value>(data_str)
crates/beads/src/commands/issue/create.rs:46:                .map_err(|e| anyhow!("Invalid JSON data: {}\n\nExpected format: '{{\"description\":\"...\",\"priority\":1,\"kind\":\"bug\"}}'", e))?;
/home/abhishek/Downloads/experiments/ai-tools/beadify/crates/beads/src/commands/issue/create.rs-47-            let kind = parsed.get("kind").and_then(|v| v.as_str()).map(|s| s.to_string());
/home/abhishek/Downloads/experiments/ai-tools/beadify/crates/beads/src/commands/issue/create.rs-48-            let priority = parsed.get("priority").and_then(|v| v.as_u64()).map(|p| p as u32);
/home/abhishek/Downloads/experiments/ai-tools/beadify/crates/beads/src/commands/issue/create.rs-49-            let desc = parsed
--
crates/beads/src/commands/issue/update.rs-49-        let json = serde_json::from_str::<serde_json::Value>(&data_str)
crates/beads/src/commands/issue/update.rs:50:            .map_err(|e| anyhow!("Invalid JSON data: {}\n\nExpected format: '{{\"description\":\"...\",\"priority\":1,\"status\":\"closed\"}}'", e))?;
/home/abhishek/Downloads/experiments/ai-tools/beadify/crates/beads/src/commands/issue/update.rs-51-
/home/abhishek/Downloads/experiments/ai-tools/beadify/crates/beads/src/commands/issue/update.rs-52-        // Apply JSON values only if not already set by flags
/home/abhishek/Downloads/experiments/ai-tools/beadify/crates/beads/src/commands/issue/update.rs-53-        if update.description.is_none() {
--
/home/abhishek/Downloads/experiments/ai-tools/beadify/crates/beads/src/commands/issue/update.rs-84-    if !has_field_updates && !has_label_operations {
crates/beads/src/commands/issue/update.rs:85:        return Err(anyhow!(
crates/beads/src/commands/issue/update.rs-86-            "No updates specified.\n\nAvailable options:\n  --title <TITLE>\n  --description <DESCRIPTION>\n  --kind <KIND>\n  --priority <PRIORITY>\n  --status <STATUS>\n  --add-label <LABELS>\n  --remove-label <LABELS>\n  --data <JSON>\n\nExample: beads issue update {} --status closed",
/home/abhishek/Downloads/experiments/ai-tools/beadify/crates/beads/src/commands/issue/update.rs-87-            id
/home/abhishek/Downloads/experiments/ai-tools/beadify/crates/beads/src/commands/issue/update.rs-88-        ));
```
</details></tool-use>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:50:49Z)**_

<think><details><summary>Thought Process</summary>
Perfect! Now I can see the problem clearly:
1. Error messages with formatting scattered across 8+ files
2. Duplicate formatting (JSON error message duplicated in create.rs and update.rs)
3. No error codes
4. No structured metadata
5. Can't change error format globally

Let me write a comprehensive answer showing how good library authors handle this, with concrete examples from well-known Rust projects.
</details></think>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:51:29Z)**_

## Problem: Current Approach is Not Evolvable

You're right - scattered `anyhow!()` strings are hard to maintain:

```rust
// Duplicated in create.rs:46 AND update.rs:50
anyhow!("Invalid JSON data: {}\n\nExpected format: '{{\"description\":\"...\",\"priority\":1,\"kind\":\"bug\"}}'", e)

// Hardcoded in update.rs:85-88
anyhow!("No updates specified.\n\nAvailable options:\n  --title <TITLE>...")
```

**Problems:**
- ❌ Can't add error codes later
- ❌ Can't change format globally (e.g., JSON output)
- ❌ Duplicated messages across files
- ❌ Testing specific errors is hard
- ❌ Can't extract for i18n
- ❌ No structured metadata

---

## How Good Libraries Do It

### Strategy 1: **Structured Error Types** (Most Important)

Separate error **data** from **presentation**.

```rust
// crates/beads-core/src/error.rs
#[derive(Debug, Error)]
pub enum BeadsError {
    // ✅ GOOD: Data, not messages
    #[error("E001: Repository not initialized")]
    RepoNotFound,
    
    #[error("E002: No fields specified for update")]
    EmptyUpdate {
        available_fields: Vec<&'static str>,  // ← Data!
        entity_id: String,
    },
    
    #[error("E003: Invalid JSON in --data flag")]
    InvalidJsonData {
        source: serde_json::Error,
        expected_fields: Vec<&'static str>,   // ← Data!
        context: &'static str,                // "create" or "update"
    },
    
    #[error("E004: Required field missing: {field}")]
    MissingRequiredField {
        field: &'static str,
        suggestion: Option<String>,           // ← Data!
    },
    
    // ... rest
}
```

**Benefits:**
- ✅ Error data is structured
- ✅ Can add fields without breaking strings
- ✅ Single definition in `error.rs`

---

### Strategy 2: **Builder Pattern for Rich Errors**

Used by `miette`, `cargo`, `rustc`:

```rust
// crates/beads-core/src/error.rs
impl BeadsError {
    pub fn empty_update(entity_id: impl Into<String>) -> Self {
        Self::EmptyUpdate {
            available_fields: vec![
                "--title", "--description", "--kind", 
                "--priority", "--status", "--add-label"
            ],
            entity_id: entity_id.into(),
        }
    }
    
    pub fn invalid_json_data(
        source: serde_json::Error,
        context: &'static str,
    ) -> Self {
        let expected_fields = match context {
            "create" => vec!["description", "priority", "kind"],
            "update" => vec!["description", "priority", "status"],
            _ => vec![],
        };
        Self::InvalidJsonData { source, expected_fields, context }
    }
}

// Usage in commands/issue/update.rs
return Err(BeadsError::empty_update(id))?;

// Usage in commands/issue/create.rs
.map_err(|e| BeadsError::invalid_json_data(e, "create"))?;
```

---

### Strategy 3: **Custom Display Trait** (Evolvable Formatting)

Centralize all formatting logic:

```rust
// crates/beads-core/src/error.rs
impl Display for BeadsError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::EmptyUpdate { available_fields, entity_id } => {
                write!(f, "No updates specified for {}.\n\n", entity_id)?;
                write!(f, "Available options:\n")?;
                for field in available_fields {
                    write!(f, "  {}\n", field)?;
                }
                write!(f, "\nExample: beads issue update {} --status closed", entity_id)
            }
            
            Self::InvalidJsonData { source, expected_fields, context } => {
                write!(f, "Invalid JSON data: {}\n\n", source)?;
                write!(f, "Expected format for {}:\n", context)?;
                write!(f, "{{\n")?;
                for field in expected_fields {
                    write!(f, "  \"{}\": <value>,\n", field)?;
                }
                write!(f, "}}")
            }
            
            Self::MissingRequiredField { field, suggestion } => {
                write!(f, "{} is required and cannot be empty", field)?;
                if let Some(hint) = suggestion {
                    write!(f, "\n\n{}", hint)?;
                }
                Ok(())
            }
            
            // ... rest handled by #[error(...)] or custom fmt
        }
    }
}
```

**Now you can:**
- ✅ Change all error formats in **one place**
- ✅ Add color/styling later
- ✅ Switch to JSON output for `--json` flag
- ✅ Add verbose mode easily

---

### Strategy 4: **Error Codes** (Like `rustc`, `cargo`)

```rust
// crates/beads-core/src/error.rs
impl BeadsError {
    pub fn code(&self) -> &'static str {
        match self {
            Self::RepoNotFound => "E001",
            Self::EmptyUpdate { .. } => "E002",
            Self::InvalidJsonData { .. } => "E003",
            Self::MissingRequiredField { .. } => "E004",
            // ...
        }
    }
    
    pub fn help_url(&self) -> Option<String> {
        Some(format!(
            "https://docs.beads.dev/errors/{}",
            self.code()
        ))
    }
}

// Custom Display includes code
impl Display for BeadsError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "error[{}]: ", self.code())?;
        // ... rest of message
        if let Some(url) = self.help_url() {
            write!(f, "\n\nFor more info: {}", url)?;
        }
        Ok(())
    }
}
```

**Output:**
```
error[E002]: No updates specified for bd-015.

Available options:
  --title
  --description
  --status

Example: beads issue update bd-015 --status closed

For more info: https://docs.beads.dev/errors/E002
```

---

### Strategy 5: **Context Attachments** (Like `anyhow::Context`)

Keep `anyhow` for CLI layer, but use typed errors underneath:

```rust
// crates/beads-core: Use typed BeadsError
pub fn update_issue(repo: &BeadsRepo, id: &str, update: IssueUpdate) 
    -> Result<Event, BeadsError> 
{
    if update.is_empty() {
        return Err(BeadsError::empty_update(id));
    }
    // ...
}

// crates/beads CLI: Add context with anyhow
use anyhow::Context;

pub fn run(...) -> anyhow::Result<()> {
    update_issue(&repo, id, update)
        .context("Failed to update issue")?;  // ← Adds stack context
    Ok(())
}
```

---

### Strategy 6: **Derive Helpers** (Advanced)

Libraries like `miette` provide diagnostic helpers:

```rust
use miette::{Diagnostic, SourceSpan};

#[derive(Error, Debug, Diagnostic)]
pub enum BeadsError {
    #[error("Invalid JSON in --data flag")]
    #[diagnostic(
        code(beads::invalid_json),
        help("Expected format: {{\"description\":\"...\",\"priority\":1}}")
    )]
    InvalidJsonData {
        #[source_code]
        src: String,
        #[label("invalid JSON here")]
        span: SourceSpan,
    },
}
```

---

## Recommended Refactor

### Phase 1: Structured Errors (High Priority)

```rust
// error.rs
#[derive(Debug, Error)]
pub enum BeadsError {
    // Core errors
    #[error("Repository not initialized")]
    RepoNotFound,
    
    // CLI-specific errors with data
    EmptyUpdate {
        entity_id: String,
        available_fields: Vec<&'static str>,
    },
    
    InvalidJsonData {
        source: serde_json::Error,
        expected_fields: Vec<&'static str>,
        context: &'static str,
    },
    
    MissingRequiredField {
        field: &'static str,
    },
    
    // ... rest
}

// Builders
impl BeadsError {
    pub fn empty_update(id: impl Into<String>) -> Self { /* ... */ }
    pub fn invalid_json_for_create(e: serde_json::Error) -> Self { /* ... */ }
    pub fn invalid_json_for_update(e: serde_json::Error) -> Self { /* ... */ }
}

// Custom Display (central formatting)
impl Display for BeadsError { /* ... */ }
```

### Phase 2: Error Codes (Medium Priority)
Add `.code()` method, help URLs

### Phase 3: Enhanced Diagnostics (Future)
Consider `miette` for rich terminal output

---

## Summary

**Key Principle:** **Separate error DATA from PRESENTATION**

| Approach | Evolvability |
|----------|--------------|
| `anyhow!("message")` | ❌ Hardcoded strings |
| `#[error("msg")]` only | ⚠️ Better but still strings |
| **Structured variants** | ✅ Data-driven |
| **Custom Display** | ✅ Central formatting |
| **Error codes** | ✅ Documentation links |
| **Builder methods** | ✅ Easy construction |

**Action:** Move CLI error strings from `commands/` → structured `BeadsError` variants in `error.rs` with custom `Display` impl.

_**Agent - sidechain (2026-01-31 06:51:29Z)**_

[SUGGESTION MODE: Suggest what the user might naturally type next into Claude Code.]

FIRST: Look at the user's recent messages and original request.

Your job is to predict what THEY would type - not what you think they should do.

THE TEST: Would they think "I was just about to type that"?

EXAMPLES:
User asked "fix the bug and run tests", bug is fixed → "run the tests"
After code written → "try it out"
Claude offers options → suggest the one the user would likely pick, based on conversation
Claude asks to continue → "yes" or "go ahead"
Task complete, obvious follow-up → "commit this" or "push it"
After error or misunderstanding → silence (let them assess/correct)

Be specific: "run the tests" beats "continue".

NEVER SUGGEST:
- Evaluative ("looks good", "thanks")
- Questions ("what about...?")
- Claude-voice ("Let me...", "I'll...", "Here's...")
- New ideas they didn't ask about
- Multiple sentences

Stay silent if the next step isn't obvious from what the user said.

Format: 2-12 words, match the user's style. Or nothing.

Reply with ONLY the suggestion, no quotes or explanation.

_**Agent - sidechain (<synthetic> 2026-01-31 06:51:30Z)**_

API Error: 400 {"type":"error","error":{"type":"invalid_request_error","message":"thinking.enabled.budget_tokens: Input should be greater than or equal to 1024"},"request_id":"req_011CXf1hdAzKGAktVbiRr8x1"}

---

_**User (2026-01-31 06:51:55Z)**_

can you write this plan in docs/ work file?? 

---

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:52:01Z)**_

<think><details><summary>Thought Process</summary>
The user wants me to write a plan for refactoring the error handling system into a docs/work file. Based on the CLAUDE.md guidelines, work documents should:
- Go in `docs/work/` with date prefixes
- Format: `docs/work/YYYY-MM-DD-<short-name>.md`
- Include clarifying questions section before implementation
- Update AGENTS.md when starting new work areas

Today's date is 2026-01-31, so the file should be named something like:
`docs/work/2026-01-31-error-refactor-plan.md` or `docs/work/2026-01-31-evolvable-errors.md`

Let me create a comprehensive plan document that includes:
1. Problem statement
2. Current state analysis
3. Proposed solution with phases
4. Implementation details
5. Clarifying questions
6. Migration strategy
7. Testing approach

I should use the Write tool to create this file.
</details></think>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:52:02Z)**_

I'll create a comprehensive plan document for the error refactoring.

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:53:41Z)**_

<tool-use data-tool-type="write" data-tool-name="Write"><details>
<summary>Tool use: **Write**</summary>

```md
# Evolvable Error System Refactoring Plan

## Problem Statement

Current error handling uses scattered `anyhow!()` strings across CLI commands, making the system hard to evolve:

**Issues:**
- ❌ Error messages hardcoded in 8+ command files
- ❌ Duplicate formatting (e.g., JSON error duplicated in `create.rs` and `update.rs`)
- ❌ Can't add error codes or help URLs later
- ❌ Can't change format globally (e.g., switch to JSON output)
- ❌ Testing specific errors is difficult
- ❌ No structured metadata for context
- ❌ Can't extract for internationalization

**Example of current problem:**
\```rust
// commands/issue/create.rs:46
anyhow!("Invalid JSON data: {}\n\nExpected format: '{{\"description\":\"...\",\"priority\":1,\"kind\":\"bug\"}}'", e)

// commands/issue/update.rs:50 (DUPLICATE!)
anyhow!("Invalid JSON data: {}\n\nExpected format: '{{\"description\":\"...\",\"priority\":1,\"status\":\"closed\"}}'", e)

// commands/issue/update.rs:85-88
anyhow!("No updates specified.\n\nAvailable options:\n  --title <TITLE>...")
\```

---

## Current State Analysis

### Error Definitions (`crates/beads-core/src/error.rs`)
\```rust
#[derive(Debug, Error)]
pub enum BeadsError {
    #[error("io error: {0}")]
    Io(#[from] std::io::Error),
    #[error("database error: {0}")]
    Db(#[from] rusqlite::Error),
    #[error("serialization error: {0}")]
    Serde(#[from] serde_json::Error),
    #[error("ulid decode error: {0}")]
    UlidDecode(#[from] ulid::DecodeError),
    #[error("beads repository already initialized")]
    AlreadyInitialized,
    #[error("beads repository not found. Run 'beads init --prefix <prefix>' to create one.")]
    RepoNotFound,
    #[error("missing repository configuration: {0}")]
    MissingConfig(&'static str),
    #[error("update requires at least one field")]
    EmptyUpdate,
    #[error("blob not found: {0}")]
    BlobNotFound(String),
    #[error("invalid hash: {0}")]
    InvalidHash(String),
    #[error("{0}")]
    Custom(String),
}
\```

**Current approach:** Simple `#[error(...)]` attributes with inline messages.

### CLI Error Usage (files using `anyhow!()`)
- `crates/beads/src/commands/issue/create.rs`
- `crates/beads/src/commands/issue/update.rs`
- `crates/beads/src/commands/create.rs` (deprecated)
- `crates/beads/src/commands/update.rs` (deprecated)
- `crates/beads/src/commands/show.rs` (deprecated)
- `crates/beads/src/commands/doc.rs`
- `crates/beads/src/commands/dep.rs`
- `crates/beads/src/commands/sync.rs`

---

## Proposed Solution: Structured, Evolvable Errors

### Core Principle
**Separate error DATA from PRESENTATION**

### Architecture Overview

\```
┌─────────────────────────────────────────────────────────┐
│ CLI Layer (crates/beads)                                │
│ - Uses anyhow::Context for stack traces                │
│ - Catches BeadsError and adds CLI context              │
└────────────────┬────────────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────────────┐
│ Core Layer (crates/beads-core)                          │
│ - BeadsError with structured variants                  │
│ - Builder methods for common errors                    │
│ - Custom Display impl (central formatting)             │
│ - Error codes + help URLs                              │
└─────────────────────────────────────────────────────────┘
\```

---

## Implementation Plan

### Phase 1: Structured Error Types (High Priority)

#### Step 1.1: Define Structured Variants

**File:** `crates/beads-core/src/error.rs`

\```rust
use std::fmt::{self, Display};
use thiserror::Error;

#[derive(Debug, Error)]
pub enum BeadsError {
    // === System Errors (auto-derived via #[from]) ===
    #[error("io error: {0}")]
    Io(#[from] std::io::Error),

    #[error("database error: {0}")]
    Db(#[from] rusqlite::Error),

    #[error("serialization error: {0}")]
    Serde(#[from] serde_json::Error),

    #[error("ulid decode error: {0}")]
    UlidDecode(#[from] ulid::DecodeError),

    // === Repository Errors ===
    #[error("beads repository already initialized")]
    AlreadyInitialized,

    #[error("beads repository not found")]
    RepoNotFound,

    #[error("missing repository configuration: {0}")]
    MissingConfig(&'static str),

    // === CLI Validation Errors (with structured data) ===

    /// No fields specified for update operation
    #[error("no updates specified")]
    EmptyUpdate {
        entity_id: String,
        available_fields: Vec<&'static str>,
    },

    /// Invalid JSON in --data flag
    #[error("invalid JSON data")]
    InvalidJsonData {
        source: serde_json::Error,
        expected_fields: Vec<&'static str>,
        context: &'static str,  // "create" or "update"
    },

    /// Required field is missing or empty
    #[error("required field missing: {field}")]
    MissingRequiredField {
        field: &'static str,
        suggestion: Option<String>,
    },

    /// Invalid document format in --doc flag
    #[error("invalid document format")]
    InvalidDocFormat {
        provided: String,
        expected: &'static str,
    },

    // === Resource Errors ===
    #[error("blob not found: {0}")]
    BlobNotFound(String),

    #[error("invalid hash: {0}")]
    InvalidHash(String),

    /// Generic fallback
    #[error("{0}")]
    Custom(String),
}

pub type Result<T> = std::result::Result<T, BeadsError>;
\```

#### Step 1.2: Add Builder Methods

**File:** `crates/beads-core/src/error.rs`

\```rust
impl BeadsError {
    /// Create EmptyUpdate error for issue updates
    pub fn empty_update(entity_id: impl Into<String>) -> Self {
        Self::EmptyUpdate {
            entity_id: entity_id.into(),
            available_fields: vec![
                "--title",
                "--description",
                "--kind",
                "--priority",
                "--status",
                "--add-label",
                "--remove-label",
                "--data",
            ],
        }
    }

    /// Create InvalidJsonData error for create command
    pub fn invalid_json_for_create(source: serde_json::Error) -> Self {
        Self::InvalidJsonData {
            source,
            expected_fields: vec!["description", "priority", "kind"],
            context: "create",
        }
    }

    /// Create InvalidJsonData error for update command
    pub fn invalid_json_for_update(source: serde_json::Error) -> Self {
        Self::InvalidJsonData {
            source,
            expected_fields: vec!["description", "priority", "status", "kind"],
            context: "update",
        }
    }

    /// Create MissingRequiredField error with optional suggestion
    pub fn missing_field(field: &'static str) -> Self {
        Self::MissingRequiredField {
            field,
            suggestion: None,
        }
    }

    /// Create MissingRequiredField error with suggestion
    pub fn missing_field_with_hint(field: &'static str, suggestion: String) -> Self {
        Self::MissingRequiredField {
            field,
            suggestion: Some(suggestion),
        }
    }

    /// Create InvalidDocFormat error
    pub fn invalid_doc_format(provided: impl Into<String>) -> Self {
        Self::InvalidDocFormat {
            provided: provided.into(),
            expected: "name:path",
        }
    }
}
\```

#### Step 1.3: Custom Display Implementation

**File:** `crates/beads-core/src/error.rs`

\```rust
impl Display for BeadsError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            // System errors use default Display from wrapped error
            Self::Io(e) => write!(f, "io error: {}", e),
            Self::Db(e) => write!(f, "database error: {}", e),
            Self::Serde(e) => write!(f, "serialization error: {}", e),
            Self::UlidDecode(e) => write!(f, "ulid decode error: {}", e),

            // Repository errors
            Self::AlreadyInitialized => {
                write!(f, "beads repository already initialized")
            }
            Self::RepoNotFound => {
                write!(f, "beads repository not found")?;
                write!(f, "\n\nRun 'beads init --prefix <prefix>' to create one")
            }
            Self::MissingConfig(key) => {
                write!(f, "missing repository configuration: {}", key)
            }

            // Structured CLI errors with rich formatting
            Self::EmptyUpdate { entity_id, available_fields } => {
                write!(f, "No updates specified for {}.\n\n", entity_id)?;
                write!(f, "Available options:\n")?;
                for field in available_fields {
                    write!(f, "  {}\n", field)?;
                }
                write!(f, "\nExample: beads issue update {} --status closed", entity_id)
            }

            Self::InvalidJsonData { source, expected_fields, context } => {
                write!(f, "Invalid JSON data: {}\n\n", source)?;
                write!(f, "Expected format for {}:\n{{\n", context)?;
                for field in expected_fields {
                    write!(f, "  \"{}\": <value>,\n", field)?;
                }
                write!(f, "}}")
            }

            Self::MissingRequiredField { field, suggestion } => {
                write!(f, "{} is required and cannot be empty", field)?;
                if let Some(hint) = suggestion {
                    write!(f, "\n\n{}", hint)?;
                }
                Ok(())
            }

            Self::InvalidDocFormat { provided, expected } => {
                write!(f, "Invalid doc format '{}'. Expected '{}'\n\n", provided, expected)?;
                write!(f, "Example: --doc readme:./README.md")
            }

            // Resource errors
            Self::BlobNotFound(hash) => write!(f, "blob not found: {}", hash),
            Self::InvalidHash(hash) => write!(f, "invalid hash: {}", hash),

            // Fallback
            Self::Custom(msg) => write!(f, "{}", msg),
        }
    }
}
\```

#### Step 1.4: Update Command Handlers

**File:** `crates/beads/src/commands/issue/update.rs`

\```rust
// BEFORE
if !has_field_updates && !has_label_operations {
    return Err(anyhow!(
        "No updates specified.\n\nAvailable options:\n  --title <TITLE>...",
        id
    ));
}

// AFTER
if !has_field_updates && !has_label_operations {
    return Err(BeadsError::empty_update(id).into());
}
\```

**File:** `crates/beads/src/commands/issue/create.rs`

\```rust
// BEFORE (line 39)
if title.trim().is_empty() {
    return Err(anyhow!("Title is required and cannot be empty"));
}

// AFTER
if title.trim().is_empty() {
    return Err(BeadsError::missing_field("title").into());
}

// BEFORE (line 46)
let parsed = serde_json::from_str::<serde_json::Value>(data_str)
    .map_err(|e| anyhow!("Invalid JSON data: {}\n\nExpected format: '{{\"description\":\"...\",\"priority\":1,\"kind\":\"bug\"}}'", e))?;

// AFTER
let parsed = serde_json::from_str::<serde_json::Value>(data_str)
    .map_err(BeadsError::invalid_json_for_create)?;

// BEFORE (line 107)
if parts.len() != 2 {
    eprintln!("Invalid doc format '{}'. Expected 'name:path'", doc_spec);
    continue;
}

// AFTER
if parts.len() != 2 {
    eprintln!("{}", BeadsError::invalid_doc_format(doc_spec));
    continue;
}
\```

**File:** `crates/beads/src/commands/issue/update.rs`

\```rust
// BEFORE (line 50)
let json = serde_json::from_str::<serde_json::Value>(&data_str)
    .map_err(|e| anyhow!("Invalid JSON data: {}\n\nExpected format: '{{\"description\":\"...\",\"priority\":1,\"status\":\"closed\"}}'", e))?;

// AFTER
let json = serde_json::from_str::<serde_json::Value>(&data_str)
    .map_err(BeadsError::invalid_json_for_update)?;
\```

---

### Phase 2: Error Codes & Help URLs (Medium Priority)

#### Step 2.1: Add Error Code System

**File:** `crates/beads-core/src/error.rs`

\```rust
impl BeadsError {
    /// Get error code for documentation/debugging
    pub fn code(&self) -> &'static str {
        match self {
            Self::Io(_) => "E000",
            Self::Db(_) => "E001",
            Self::Serde(_) => "E002",
            Self::UlidDecode(_) => "E003",
            Self::AlreadyInitialized => "E100",
            Self::RepoNotFound => "E101",
            Self::MissingConfig(_) => "E102",
            Self::EmptyUpdate { .. } => "E200",
            Self::InvalidJsonData { .. } => "E201",
            Self::MissingRequiredField { .. } => "E202",
            Self::InvalidDocFormat { .. } => "E203",
            Self::BlobNotFound(_) => "E300",
            Self::InvalidHash(_) => "E301",
            Self::Custom(_) => "E999",
        }
    }

    /// Get help URL for this error
    pub fn help_url(&self) -> Option<String> {
        Some(format!(
            "https://docs.beads.dev/errors/{}",
            self.code()
        ))
    }
}
\```

#### Step 2.2: Update Display to Include Codes

\```rust
impl Display for BeadsError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // Print error code prefix
        write!(f, "error[{}]: ", self.code())?;

        // ... existing message formatting ...

        // Optionally add help URL at end
        if let Some(url) = self.help_url() {
            write!(f, "\n\nFor more information: {}", url)?;
        }

        Ok(())
    }
}
\```

**Example output:**
\```
error[E200]: No updates specified for bd-015.

Available options:
  --title
  --description
  --status

Example: beads issue update bd-015 --status closed

For more information: https://docs.beads.dev/errors/E200
\```

---

### Phase 3: Enhanced Diagnostics (Future)

#### Option A: Colored Output (using `colored` crate)

\```rust
// Add dependency: colored = "2"

impl Display for BeadsError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use colored::*;

        match self {
            Self::EmptyUpdate { entity_id, available_fields } => {
                writeln!(f, "{}", "No updates specified".red().bold())?;
                writeln!(f, "\n{}", "Available options:".cyan())?;
                for field in available_fields {
                    writeln!(f, "  {}", field.green())?;
                }
                write!(f, "\n{} beads issue update {} --status closed",
                    "Example:".yellow(), entity_id)
            }
            // ...
        }
    }
}
\```

#### Option B: Rich Diagnostics (using `miette` crate)

\```rust
// Add dependency: miette = { version = "5", features = ["fancy"] }

use miette::{Diagnostic, SourceSpan};

#[derive(Error, Debug, Diagnostic)]
pub enum BeadsError {
    #[error("Invalid JSON in --data flag")]
    #[diagnostic(
        code(beads::invalid_json),
        help("Expected format: {{\"description\":\"...\",\"priority\":1}}")
    )]
    InvalidJsonData {
        #[source_code]
        src: String,

        #[label("invalid JSON here")]
        span: SourceSpan,
    },
    // ...
}
\```

---

## Migration Strategy

### Step-by-Step Migration

1. **Phase 1.1-1.3:** Add new error variants + builders to `beads-core/src/error.rs`
   - No breaking changes, purely additive
   - Existing code continues to work

2. **Phase 1.4:** Migrate CLI commands one file at a time
   - Start with `commands/issue/update.rs` (most complex)
   - Then `commands/issue/create.rs`
   - Then deprecated commands
   - Each migration is self-contained

3. **Test after each file migration:**
   \```bash
   cargo build
   cargo test
   # Manual testing of specific command
   beads issue update bd-001
   beads issue create --title "test"
   \```

4. **Phase 2:** Add error codes (non-breaking)
   - Adds methods to `BeadsError`
   - Update `Display` impl
   - Test output format changes

5. **Phase 3:** Optional enhancements (future work)

### Backward Compatibility

- ✅ No breaking changes to `beads-core` API
- ✅ Error messages improve but functionality unchanged
- ✅ Old deprecated commands still work
- ✅ `events.jsonl` format unchanged

---

## Testing Strategy

### Unit Tests

**File:** `crates/beads-core/src/error.rs`

\```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_empty_update_formatting() {
        let err = BeadsError::empty_update("bd-015");
        let msg = err.to_string();

        assert!(msg.contains("No updates specified"));
        assert!(msg.contains("bd-015"));
        assert!(msg.contains("--title"));
        assert!(msg.contains("--status"));
        assert!(msg.contains("Example:"));
    }

    #[test]
    fn test_invalid_json_for_create() {
        let json_err = serde_json::from_str::<serde_json::Value>("invalid")
            .unwrap_err();
        let err = BeadsError::invalid_json_for_create(json_err);
        let msg = err.to_string();

        assert!(msg.contains("Invalid JSON"));
        assert!(msg.contains("create"));
        assert!(msg.contains("description"));
        assert!(msg.contains("priority"));
    }

    #[test]
    fn test_error_codes() {
        assert_eq!(BeadsError::RepoNotFound.code(), "E101");
        assert_eq!(BeadsError::empty_update("test").code(), "E200");
    }

    #[test]
    fn test_help_urls() {
        let err = BeadsError::RepoNotFound;
        assert_eq!(
            err.help_url(),
            Some("https://docs.beads.dev/errors/E101".to_string())
        );
    }
}
\```

### Integration Tests

**File:** `crates/beads/tests/error_messages.rs` (new file)

\```rust
use assert_cmd::Command;
use predicates::prelude::*;

#[test]
fn empty_update_shows_available_options() {
    Command::cargo_bin("beads")
        .unwrap()
        .args(&["issue", "update", "bd-001"])
        .assert()
        .failure()
        .stderr(predicate::str::contains("No updates specified"))
        .stderr(predicate::str::contains("--title"))
        .stderr(predicate::str::contains("--status"))
        .stderr(predicate::str::contains("Example:"));
}

#[test]
fn invalid_json_shows_expected_format() {
    Command::cargo_bin("beads")
        .unwrap()
        .args(&["issue", "create", "--title", "test", "--data", "invalid"])
        .assert()
        .failure()
        .stderr(predicate::str::contains("Invalid JSON"))
        .stderr(predicate::str::contains("Expected format"));
}

#[test]
fn missing_title_shows_error() {
    Command::cargo_bin("beads")
        .unwrap()
        .args(&["issue", "create", "--title", ""])
        .assert()
        .failure()
        .stderr(predicate::str::contains("title"))
        .stderr(predicate::str::contains("required"));
}
\```

---

## Clarifying Questions

### Before Implementation

1. **Error Code Format:**
   - Use simple numeric codes (`E001`, `E002`, ...) like rustc?
   - Or semantic codes (`REPO_001`, `CLI_001`, ...)?
   - Current proposal: Simple numeric with ranges (E000-E099 = system, E100-E199 = repo, E200-E299 = CLI)

2. **Help URLs:**
   - Create actual documentation at `docs.beads.dev/errors/*`?
   - Or link to GitHub issues/wiki?
   - Current proposal: Document in repo first (`docs/errors/E001.md`), publish later

3. **Colored Output:**
   - Add colored output now (Phase 1) or later (Phase 3)?
   - Respect `NO_COLOR` env var?
   - Current proposal: Add in Phase 3, respect `NO_COLOR`

4. **Verbose Mode:**
   - Add `--verbose` flag that shows error codes + stack traces?
   - Current proposal: Yes, add `BEADS_VERBOSE` env var

5. **JSON Output:**
   - Support `--json` flag for machine-readable errors?
   - Current proposal: Phase 3 enhancement

6. **Deprecated Commands:**
   - Migrate deprecated commands (`create.rs`, `update.rs`, `show.rs`) or skip?
   - Current proposal: Migrate for consistency, even if deprecated

---

## Benefits After Refactor

### Immediate (Phase 1)
✅ Single source of truth for error messages
✅ No duplicated formatting logic
✅ Easy to test specific error messages
✅ Structured error metadata
✅ Consistent error format across all commands

### Medium Term (Phase 2)
✅ Error codes for documentation
✅ Help URLs for detailed explanations
✅ Can filter/search by error code
✅ Analytics on which errors users hit most

### Long Term (Phase 3)
✅ Rich terminal diagnostics
✅ JSON output mode
✅ Internationalization ready
✅ Custom error reporters (e.g., send to logging service)

---

## Example Usage After Refactor

### Before
\```rust
// create.rs
if title.trim().is_empty() {
    return Err(anyhow!("Title is required and cannot be empty"));
}

// update.rs
if !has_updates {
    return Err(anyhow!(
        "No updates specified.\n\nAvailable options:\n  --title <TITLE>\n  --description <DESCRIPTION>\n  --kind <KIND>\n  --priority <PRIORITY>\n  --status <STATUS>\n  --add-label <LABELS>\n  --remove-label <LABELS>\n  --data <JSON>\n\nExample: beads issue update {} --status closed",
        id
    ));
}

// create.rs (duplicate!)
.map_err(|e| anyhow!("Invalid JSON data: {}\n\nExpected format: '{{\"description\":\"...\",\"priority\":1,\"kind\":\"bug\"}}'", e))?
\```

### After
\```rust
// All commands
if title.trim().is_empty() {
    return Err(BeadsError::missing_field("title").into());
}

if !has_updates {
    return Err(BeadsError::empty_update(id).into());
}

.map_err(BeadsError::invalid_json_for_create)?
\```

**All formatting lives in one place:** `beads-core/src/error.rs`

---

## Files to Modify

### Phase 1
- `crates/beads-core/src/error.rs` (major changes)
- `crates/beads/src/commands/issue/create.rs` (minor changes)
- `crates/beads/src/commands/issue/update.rs` (minor changes)
- `crates/beads/src/commands/create.rs` (minor changes)
- `crates/beads/src/commands/update.rs` (minor changes)
- `crates/beads/src/commands/doc.rs` (minor changes)
- `crates/beads/src/commands/dep.rs` (minor changes)

### Phase 2
- `crates/beads-core/src/error.rs` (add code/URL methods)
- `docs/errors/*.md` (new error documentation files)

### Phase 3 (Optional)
- `Cargo.toml` (add `colored` or `miette` dependency)
- `crates/beads-core/src/error.rs` (enhance Display impl)

---

## Timeline Estimate

- **Phase 1:** 2-3 hours (core refactor + migration)
- **Phase 2:** 1-2 hours (error codes + help system)
- **Phase 3:** 1-2 hours (enhanced diagnostics)

**Total:** 4-7 hours for complete implementation

---

## Success Criteria

✅ Zero `anyhow!()` with hardcoded multi-line messages in CLI commands
✅ All CLI validation errors use structured `BeadsError` variants
✅ Error messages formatted consistently via `Display` impl
✅ Can change error format globally by editing one file
✅ Can add new error metadata (codes, URLs) without touching commands
✅ Integration tests verify error messages
✅ No behavioral changes to user-facing functionality

---

## References

- rustc error handling: https://rustc-dev-guide.rust-lang.org/diagnostics.html
- miette crate: https://docs.rs/miette/
- thiserror crate: https://docs.rs/thiserror/
- Rust API Guidelines (error handling): https://rust-lang.github.io/api-guidelines/interoperability.html#error-types-are-meaningful-and-well-behaved-c-good-err

```
```
File created successfully at: /home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2026-01-31-evolvable-error-system.md
```
</details></tool-use>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:54:31Z)**_

<think><details><summary>Thought Process</summary>
The user sent another message "read agents md file" while I was working. Let me complete this response and then address that request.
</details></think>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:54:35Z)**_

Created comprehensive plan at `docs/work/2026-01-31-evolvable-error-system.md`

**Plan includes:**
- Problem statement & current state analysis
- 3-phase implementation (structured errors → error codes → diagnostics)
- Builder pattern examples
- Migration strategy (file-by-file, non-breaking)
- Testing strategy (unit + integration tests)
- Clarifying questions
- 4-7 hour timeline estimate

**Key approach:** Separate error **data** from **presentation** → all formatting in one place (`error.rs`).

Now let me read the agents.md file you mentioned:

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:54:35Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 pattern `**/AGENTS.md`
```
No files found
```
</details></tool-use>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:54:36Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 pattern `**/*agent*.md`
```
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2026-01-31-natural-agent-interface-implementation.md
```
</details></tool-use>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:54:41Z)**_

<think><details><summary>Thought Process</summary>
Hmm, there's no AGENTS.md file but there is a natural-agent-interface-implementation.md. The user might be referring to that, or they might want me to check the CLAUDE.md which mentioned updating AGENTS.md. Let me check CLAUDE.md again to see what it says about AGENTS.md.
</details></think>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:54:42Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `./` pattern `AGENTS\.md`
```
CLAUDE.md:67:- Update this AGENTS.md when starting new work areas
CLAUDE.md:71:2. Add guidance section to AGENTS.md if establishing new patterns
docs/work/2026-01-31-natural-agent-interface-implementation.md:169:4. **Commit changes** - Following AGENTS.md guidelines
.specstory/history/2026-01-31_06-47-12Z-read-the-docs-work.md:1514:- Update AGENTS.md when starting new work areas
.specstory/history/2026-01-31_06-47-12Z-read-the-docs-work.md:2371: pattern `**/AGENTS.md`
.specstory/history/2026-01-31_06-47-12Z-read-the-docs-work.md:2390:Hmm, there's no AGENTS.md file but there is a natural-agent-interface-implementation.md. The user might be referring to that, or they might want me to check the CLAUDE.md which mentioned updating AGENTS.md. Let me check CLAUDE.md again to see what it says about AGENTS.md.
.specstory/history/2026-01-31_05-18-07Z-command-name-model-command.md:230:    81→- Update this AGENTS.md when starting new work areas
.specstory/history/2026-01-31_05-18-07Z-command-name-model-command.md:234:    85→2. Add guidance section to AGENTS.md if establishing new patterns
```
</details></tool-use>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:54:47Z)**_

<think><details><summary>Thought Process</summary>
I see. The CLAUDE.md mentions AGENTS.md but the file doesn't exist in the repo. It seems like it's supposed to be a guidance file for establishing patterns when working on new areas. The user might want me to:

1. Check if AGENTS.md should exist (according to CLAUDE.md workflow)
2. Create it if needed for this error handling work
3. Or they might have meant a different file

Let me check the CLAUDE.md section more carefully and also check the natural-agent file they have.
</details></think>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:54:48Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./CLAUDE.md`
```
    60→## Documentation & Planning
    61→
    62→### Work Documents
    63→
    64→Design docs, planning, and research should go in `docs/work/` with date prefixes:
    65→- Format: `docs/work/YYYY-MM-DD-<short-name>.md`
    66→- Include clarifying questions section before implementation
    67→- Update this AGENTS.md when starting new work areas
    68→
    69→**Example workflow:**
    70→1. Create work doc in `docs/work/`
    71→2. Add guidance section to AGENTS.md if establishing new patterns
    72→3. Include clarifying questions in the doc
    73→4. Reference the work doc from related issues/threads
    74→
    75→
```
</details></tool-use>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:54:52Z)**_

<think><details><summary>Thought Process</summary>
I see. The CLAUDE.md says "Update this AGENTS.md" but AGENTS.md doesn't exist. It seems like it's a typo in CLAUDE.md - it should probably say "Update CLAUDE.md" or there should be an AGENTS.md file that doesn't exist yet.

Since the user asked me to "read agents md file", they might be:
1. Asking me to check if it exists
2. Wanting me to create it based on the workflow mentioned in CLAUDE.md
3. Referring to the error handling work pattern we just documented

Let me explain what I found and ask for clarification.
</details></think>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:54:56Z)**_

I don't see an `AGENTS.md` file in the repo. CLAUDE.md references it at line 67:

```markdown
- Update this AGENTS.md when starting new work areas
```

But the file doesn't exist. 

**Options:**

1. **It's a typo in CLAUDE.md** - should say "Update CLAUDE.md" instead
2. **AGENTS.md should exist** - a guidance file for patterns/conventions that hasn't been created yet
3. **You meant a different file** - like the natural-agent-interface doc

Should I:
- Create an AGENTS.md file with error handling patterns from our discussion?
- Fix the CLAUDE.md reference?
- Read a different file you had in mind?

_**Agent - sidechain (2026-01-31 06:54:56Z)**_

[SUGGESTION MODE: Suggest what the user might naturally type next into Claude Code.]

FIRST: Look at the user's recent messages and original request.

Your job is to predict what THEY would type - not what you think they should do.

THE TEST: Would they think "I was just about to type that"?

EXAMPLES:
User asked "fix the bug and run tests", bug is fixed → "run the tests"
After code written → "try it out"
Claude offers options → suggest the one the user would likely pick, based on conversation
Claude asks to continue → "yes" or "go ahead"
Task complete, obvious follow-up → "commit this" or "push it"
After error or misunderstanding → silence (let them assess/correct)

Be specific: "run the tests" beats "continue".

NEVER SUGGEST:
- Evaluative ("looks good", "thanks")
- Questions ("what about...?")
- Claude-voice ("Let me...", "I'll...", "Here's...")
- New ideas they didn't ask about
- Multiple sentences

Stay silent if the next step isn't obvious from what the user said.

Format: 2-12 words, match the user's style. Or nothing.

Reply with ONLY the suggestion, no quotes or explanation.

_**Agent - sidechain (<synthetic> 2026-01-31 06:54:56Z)**_

API Error: 400 {"type":"error","error":{"type":"invalid_request_error","message":"thinking.enabled.budget_tokens: Input should be greater than or equal to 1024"},"request_id":"req_011CXf1xrx89nPirintLtEYx"}

---

_**User (2026-01-31 06:55:26Z)**_

                                                                                                                                                                             claude.md pls

---

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:55:29Z)**_

<think><details><summary>Thought Process</summary>
The user wants me to read the CLAUDE.md file. Let me read the full file to see what they want me to look at in context of our error handling discussion.
</details></think>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:55:30Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./CLAUDE.md`
```
     1→
     2→## Git Commit Guidelines
     3→
     4→**IMPORTANT:** When committing changes for an issue:
     5→
     6→```bash
     7→# 1. Only add files changed for THIS specific issue (never use git add .)
     8→git add path/to/file1.rs path/to/file2.rs
     9→
    10→# 2. Commit with issue number in title (conventional commit format)
    11→git commit -m "fix(bd-015): resolve sync driver race condition"
    12→git commit -m "feat(bd-023): add search filter by priority"
    13→git commit -m "refactor(bd-018): simplify event parsing logic"
    14→```
    15→
    16→**Commit format:**
    17→- **Format:** `<type>(<issue-id>): <short description>`
    18→- **Types:** `fix`, `feat`, `refactor`, `docs`, `test`, `chore`
    19→- **Issue ID:** Always include the issue number (e.g., `bd-015`)
    20→- **Description:** Keep it short and descriptive (50-72 chars recommended)
    21→
    22→**Rules:**
    23→- ✅ **Always include issue number** in commit title
    24→- ✅ **Only commit files changed** for the current issue (never use `git add .`)
    25→- ✅ **Use conventional commit format** (`type(issue-id): description`)
    26→- ✅ **Keep titles short** and focused
    27→
    28→
    29→
    30→
    31→## Workflow for Working on Issues
    32→
    33→### Standard Issue Workflow (Required for `kind=feature`)
    34→
    35→When working on an issue, follow this lifecycle (example):
    36→
    37→```bash
    38→# 1. Mark issue as in_progress before starting work
    39→beads update bd-015 --status in_progress
    40→
    41→# 2. Write a short approach/plan (before writing code)
    42→# Document the approach: what needs to be done, how, and any key considerations
    43→
    44→# 3. Implement the solution
    45→# ... make code changes, implement features, etc ...
    46→
    47→# 4. When implementation is complete, mark for review
    48→beads update bd-015 --status review
    49→
    50→# 5. After user testing/validation, mark as closed
    51→beads update bd-015 --status closed
    52→
    53→# 6. Commit only the files changed for this issue with the issue name in the commit message
    54→git add path/to/file1.rs path/to/file2.rs
    55→git commit -m "fix(bd-015): resolve sync driver race condition"
    56→```
    57→
    58→**Note:** This workflow is **mandatory** for issues with `kind=feature`.
    59→
    60→## Documentation & Planning
    61→
    62→### Work Documents
    63→
    64→Design docs, planning, and research should go in `docs/work/` with date prefixes:
    65→- Format: `docs/work/YYYY-MM-DD-<short-name>.md`
    66→- Include clarifying questions section before implementation
    67→- Update this AGENTS.md when starting new work areas
    68→
    69→**Example workflow:**
    70→1. Create work doc in `docs/work/`
    71→2. Add guidance section to AGENTS.md if establishing new patterns
    72→3. Include clarifying questions in the doc
    73→4. Reference the work doc from related issues/threads
    74→
    75→
```
</details></tool-use>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:55:35Z)**_

<think><details><summary>Thought Process</summary>
I see the issue now. Lines 67 and 71 reference "AGENTS.md" but the file doesn't exist. The user is asking me to look at CLAUDE.md in the context of our error handling work plan.

Looking at the workflow section, it seems like:
1. We should create work docs in `docs/work/` ✅ (we did this)
2. We should update AGENTS.md when establishing new patterns - but this file doesn't exist

The question is: should we create AGENTS.md for the error handling pattern we're establishing? Or is this a documentation issue in CLAUDE.md itself?

Let me point this out to the user and ask what they want to do.
</details></think>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:55:41Z)**_

I see the issue in CLAUDE.md:

**Lines 67 & 71 reference `AGENTS.md` but the file doesn't exist:**

```markdown
67: - Update this AGENTS.md when starting new work areas
71: 2. Add guidance section to AGENTS.md if establishing new patterns
```

**Context:** We just created a work doc for the error handling refactor at `docs/work/2026-01-31-evolvable-error-system.md`.

**Questions:**

1. **Should I create `AGENTS.md`?** 
   - Add error handling patterns/conventions for agents working on this codebase?
   - Location: root `AGENTS.md` or `docs/AGENTS.md`?

2. **Is this a typo in CLAUDE.md?**
   - Should line 67 say "Update CLAUDE.md" instead?
   - Or was AGENTS.md intended but never created?

3. **What should go in AGENTS.md?**
   - Error handling conventions (our current topic)?
   - CLI command patterns?
   - Testing guidelines?
   - All architectural patterns?

Want me to create it based on the error handling patterns we discussed?

_**Agent - sidechain (2026-01-31 06:55:41Z)**_

[SUGGESTION MODE: Suggest what the user might naturally type next into Claude Code.]

FIRST: Look at the user's recent messages and original request.

Your job is to predict what THEY would type - not what you think they should do.

THE TEST: Would they think "I was just about to type that"?

EXAMPLES:
User asked "fix the bug and run tests", bug is fixed → "run the tests"
After code written → "try it out"
Claude offers options → suggest the one the user would likely pick, based on conversation
Claude asks to continue → "yes" or "go ahead"
Task complete, obvious follow-up → "commit this" or "push it"
After error or misunderstanding → silence (let them assess/correct)

Be specific: "run the tests" beats "continue".

NEVER SUGGEST:
- Evaluative ("looks good", "thanks")
- Questions ("what about...?")
- Claude-voice ("Let me...", "I'll...", "Here's...")
- New ideas they didn't ask about
- Multiple sentences

Stay silent if the next step isn't obvious from what the user said.

Format: 2-12 words, match the user's style. Or nothing.

Reply with ONLY the suggestion, no quotes or explanation.

_**Agent - sidechain (<synthetic> 2026-01-31 06:55:42Z)**_

API Error: 400 {"type":"error","error":{"type":"invalid_request_error","message":"thinking.enabled.budget_tokens: Input should be greater than or equal to 1024"},"request_id":"req_011CXf22DUzPf34K8X2zNcEg"}

---

_**User (2026-01-31 06:57:18Z)**_

ignore agents.md abandon this task. 


focus on the task we were dojg before --- 
analyse the last 10 git commits + the doc 
                                                         📄 Create(docs/work/2026-01-31-cli-error-handling-iteration-2.md) 
to see ewhat was implemented and weite code plan for errora 

---

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:57:22Z)**_

<think><details><summary>Thought Process</summary>
The user wants me to:
1. Abandon the AGENTS.md discussion
2. Focus back on the error handling task
3. Analyze the last 10 git commits
4. Read the docs/work/2026-01-31-cli-error-handling-iteration-2.md file (if it exists)
5. See what was already implemented
6. Write a code plan for implementing the evolvable error system

Let me start by checking git commits and looking for that iteration-2 doc.
</details></think>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:57:23Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>
Get last 10 git commits

`git log --oneline -10`
```
90effd9 docs(cli): add final summary of CLI error handling implementation
5ee6e2d docs(cli): document iteration 2 of CLI error handling improvements
21a1e01 feat(cli): improve non-enum error messages with helpful hints
719214a docs(cli): document iteration 1 of CLI error handling improvements
8b60dc3 feat(cli): implement custom ValueEnum with case-insensitive matching and numeric aliases
b04d2be feat(cli): migrate search command to typed enums
df6effa refactor(cli): update issue command handlers to use pre-validated typed enums
8409eec feat(cli): update IssueCommand to use typed enums, hide deprecated commands
70695ef feat(cli): add ValueEnum derive to enums with numeric backward compat
66f01bc docs: update bulk issues work document
```
</details></tool-use>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:57:24Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 pattern `docs/work/*cli-error*.md`
```
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2026-01-31-cli-error-handling.md
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2026-01-31-cli-error-handling-iteration-1.md
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2026-01-31-cli-error-handling-iteration-2.md
/home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2026-01-31-cli-error-handling-final.md
```
</details></tool-use>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:57:28Z)**_

<think><details><summary>Thought Process</summary>
Good, there are multiple CLI error handling docs. Let me read iteration-2 and final to see what was implemented, then look at the git diffs to understand what code changes were made.
</details></think>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:57:29Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./docs/work/2026-01-31-cli-error-handling-iteration-2.md`
```
     1→# CLI Error Handling - Iteration 2
     2→
     3→## Summary
     4→
     5→Improved non-enum error messages to provide helpful context and actionable suggestions.
     6→
     7→## Changes Made
     8→
     9→### 1. Improved "No updates specified" Error
    10→
    11→**File:** `crates/beads/src/commands/issue/update.rs`
    12→
    13→**Before:**
    14→```
    15→Error: No updates specified
    16→```
    17→
    18→**After:**
    19→```
    20→Error: No updates specified.
    21→
    22→Available options:
    23→  --title <TITLE>
    24→  --description <DESCRIPTION>
    25→  --kind <KIND>
    26→  --priority <PRIORITY>
    27→  --status <STATUS>
    28→  --add-label <LABELS>
    29→  --remove-label <LABELS>
    30→  --data <JSON>
    31→
    32→Example: beads issue update bd-095 --status closed
    33→```
    34→
    35→### 2. Improved "Invalid JSON data" Error
    36→
    37→**File:** `crates/beads/src/commands/issue/create.rs` and `update.rs`
    38→
    39→**Before:**
    40→```
    41→Error: Invalid JSON data: expected value at line 1 column 1
    42→```
    43→
    44→**After:**
    45→```
    46→Error: Invalid JSON data: expected value at line 1 column 1
    47→
    48→Expected format: '{"description":"...","priority":1,"kind":"bug"}'
    49→```
    50→
    51→### 3. Improved "Repository not found" Error
    52→
    53→**File:** `crates/beads-core/src/error.rs`
    54→
    55→**Before:**
    56→```
    57→Error: beads repository not found
    58→```
    59→
    60→**After:**
    61→```
    62→Error: beads repository not found. Run 'beads init --prefix <prefix>' to create one.
    63→```
    64→
    65→## Test Results
    66→
    67→### ✅ All Error Messages Now Helpful
    68→
    69→```bash
    70→# No updates specified
    71→$ beads issue update bd-095
    72→Error: No updates specified.
    73→
    74→Available options:
    75→  --title <TITLE>
    76→  --description <DESCRIPTION>
    77→  ...
    78→
    79→# Invalid JSON
    80→$ beads issue create --title "Test" --data "invalid json"
    81→Error: Invalid JSON data: expected value at line 1 column 1
    82→
    83→Expected format: '{"description":"...","priority":1,"kind":"bug"}'
    84→
    85→# Missing repo
    86→$ beads issue list  # (in /tmp)
    87→Error: beads repository not found. Run 'beads init --prefix <prefix>' to create one.
    88→```
    89→
    90→## Summary of Both Iterations
    91→
    92→| Error Type | Before | After |
    93→|------------|--------|-------|
    94→| Invalid enum value | Silent default / cryptic error | Clear error with possible values list |
    95→| Case sensitivity | Only lowercase worked | Case-insensitive (HIGH, High, high all work) |
    96→| Numeric priority | Not supported | 0-3 aliases for low-urgent |
    97→| No updates specified | "No updates specified" | Lists all available options with example |
    98→| Invalid JSON | "Invalid JSON data: {error}" | Shows expected format hint |
    99→| Missing repo | "beads repository not found" | Suggests `beads init` command |
   100→
   101→## Next Steps (Optional)
   102→
   103→1. Add integration tests with `assert_cmd` to verify error messages
   104→2. Consider adding similar improvements to other commands (dep, label, doc)
   105→3. Document the CLI error handling patterns for future contributors
   106→
```
</details></tool-use>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:57:29Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./docs/work/2026-01-31-cli-error-handling-final.md`
```
     1→# CLI Error Handling Implementation - Final Summary
     2→
     3→## Overview
     4→
     5→Successfully implemented comprehensive CLI error handling improvements for the beads CLI tool. The implementation provides helpful, context-aware error messages with automatic validation at the clap layer.
     6→
     7→## Key Improvements
     8→
     9→### 1. Enum Validation with ValueEnum
    10→
    11→**Files Modified:**
    12→- [`crates/beads/src/cli/enums.rs`](crates/beads/src/cli/enums.rs:1) - Custom ValueEnum implementation
    13→- [`crates/beads/src/main.rs`](crates/beads/src/main.rs:1) - CLI argument definitions
    14→
    15→**Features:**
    16→- **Case-insensitive matching**: `HIGH`, `High`, `high` all accepted
    17→- **Numeric aliases**: `0`, `1`, `2`, `3` map to `low`, `medium`, `high`, `urgent`
    18→- **Multiple format support**: `in-progress`, `in_progress`, `inprogress` all work
    19→- **Automatic help text**: `--help` shows possible values with descriptions
    20→
    21→**Example:**
    22→```bash
    23→$ beads issue create --title "Test" --priority HIGH --kind BUG
    24→Created issue bd-097
    25→
    26→$ beads issue create --title "Test" --priority critical
    27→error: invalid value 'critical' for '--priority <PRIORITY>'
    28→  [possible values: low, medium, high, urgent]
    29→```
    30→
    31→### 2. Hidden Deprecated Commands
    32→
    33→**File:** [`crates/beads/src/main.rs`](crates/beads/src/main.rs:27)
    34→
    35→Old commands (`create`, `show`, `list`, `update`) are now hidden from `--help` but still work for backward compatibility:
    36→
    37→```bash
    38→$ beads --help
    39→Commands:
    40→  init    Initialize a new beads repository
    41→  sync    Apply new events from the log to the local database
    42→  search  Search issues by text query with optional filters
    43→  ready   Show the next issue to work on, grouped by priority
    44→  dep     Manage issue dependencies
    45→  label   Manage issue labels
    46→  doc     Manage issue documents
    47→  delete  Delete one or more issues
    48→  issue   Manage issues (create, update, list, show)  # <-- Canonical path
    49→  help    Print this message or the help of the given subcommand(s)
    50→```
    51→
    52→### 3. Improved Error Messages
    53→
    54→#### "No updates specified" Error
    55→**File:** [`crates/beads/src/commands/issue/update.rs`](crates/beads/src/commands/issue/update.rs:97)
    56→
    57→```bash
    58→$ beads issue update bd-095
    59→Error: No updates specified.
    60→
    61→Available options:
    62→  --title <TITLE>
    63→  --description <DESCRIPTION>
    64→  --kind <KIND>
    65→  --priority <PRIORITY>
    66→  --status <STATUS>
    67→  --add-label <LABELS>
    68→  --remove-label <LABELS>
    69→  --data <JSON>
    70→
    71→Example: beads issue update bd-095 --status closed
    72→```
    73→
    74→#### "Invalid JSON data" Error
    75→**Files:** 
    76→- [`crates/beads/src/commands/issue/create.rs`](crates/beads/src/commands/issue/create.rs:46)
    77→- [`crates/beads/src/commands/issue/update.rs`](crates/beads/src/commands/issue/update.rs:53)
    78→
    79→```bash
    80→$ beads issue create --title "Test" --data "invalid"
    81→Error: Invalid JSON data: expected value at line 1 column 1
    82→
    83→Expected format: '{"description":"...","priority":1,"kind":"bug"}'
    84→```
    85→
    86→#### "Repository not found" Error
    87→**File:** [`crates/beads-core/src/error.rs`](crates/beads-core/src/error.rs:16)
    88→
    89→```bash
    90→$ beads issue list  # (in directory without .beads/)
    91→Error: beads repository not found. Run 'beads init --prefix <prefix>' to create one.
    92→```
    93→
    94→## Files Changed
    95→
    96→| File | Changes |
    97→|------|---------|
    98→| `crates/beads/src/cli/enums.rs` | Custom ValueEnum with case-insensitive matching and numeric aliases |
    99→| `crates/beads/src/cli/mod.rs` | Removed `errors` module reference |
   100→| `crates/beads/src/cli/errors.rs` | Deleted (no longer needed) |
   101→| `crates/beads/src/main.rs` | Typed enums in CLI args, hidden deprecated commands |
   102→| `crates/beads/src/commands/issue/create.rs` | Use pre-validated types, improved JSON error |
   103→| `crates/beads/src/commands/issue/update.rs` | Use pre-validated types, improved "no updates" error |
   104→| `crates/beads/src/commands/issue/list.rs` | Use pre-validated types |
   105→| `crates/beads-core/src/error.rs` | Improved repo not found error message |
   106→
   107→## Testing
   108→
   109→All scenarios tested and working:
   110→
   111→| Scenario | Result |
   112→|----------|--------|
   113→| Valid enum values | ✅ Works |
   114→| Case-insensitive (HIGH, High, high) | ✅ Works |
   115→| Numeric priority (0-3) | ✅ Works |
   116→| Invalid enum values | ✅ Clear error with valid values |
   117→| Missing repo | ✅ Suggests init command |
   118→| Invalid JSON | ✅ Shows expected format |
   119→| No updates specified | ✅ Lists available options |
   120→| Deprecated commands | ✅ Hidden but functional |
   121→
   122→## Documentation
   123→
   124→- [`docs/work/2026-01-31-cli-error-handling.md`](docs/work/2026-01-31-cli-error-handling.md) - Original design document
   125→- [`docs/work/2026-01-31-cli-error-handling-iteration-1.md`](docs/work/2026-01-31-cli-error-handling-iteration-1.md) - Iteration 1: ValueEnum implementation
   126→- [`docs/work/2026-01-31-cli-error-handling-iteration-2.md`](docs/work/2026-01-31-cli-error-handling-iteration-2.md) - Iteration 2: Non-enum error improvements
   127→- [`docs/work/2026-01-31-cli-error-handling-final.md`](docs/work/2026-01-31-cli-error-handling-final.md) - This summary
   128→
   129→## Backward Compatibility
   130→
   131→- Old commands still work (`beads create`, `beads update`, etc.)
   132→- Numeric priorities still accepted
   133→- JSON `--data` flag still works alongside new typed flags
   134→- events.jsonl format unchanged
   135→
   136→## Future Enhancements (Optional)
   137→
   138→1. Add integration tests with `assert_cmd` to verify error messages
   139→2. Apply similar error handling patterns to `dep`, `label`, `doc` subcommands
   140→3. Add shell completion support for enum values
   141→
```
</details></tool-use>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:57:33Z)**_

<think><details><summary>Thought Process</summary>
Good. Now let me check the git diffs to see what was actually implemented in the code. I'll look at the commits related to error handling.
</details></think>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:57:34Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>
Show iteration 2 commit changes

`git show 21a1e01 --stat`
```
commit 21a1e0132615ea3b8e892c4a5d716fdad8539f53
Author: Abhishek Tripathi <abhishek.tripathi456@gmail.com>
Date:   Sat Jan 31 12:23:42 2026 +0530

    feat(cli): improve non-enum error messages with helpful hints

 crates/beads-core/src/error.rs            | 2 +-
 crates/beads/src/commands/issue/create.rs | 2 +-
 crates/beads/src/commands/issue/update.rs | 7 +++++--
 3 files changed, 7 insertions(+), 4 deletions(-)
```
</details></tool-use>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:57:36Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>
Show error handling changes in key files

`git diff 8b60dc3^..21a1e01 -- crates/beads-core/src/error.rs crates/beads/src/commands/issue/update.rs crates/beads/src/commands/issue/create.rs`
```
diff --git a/crates/beads-core/src/error.rs b/crates/beads-core/src/error.rs
index 807aa31..bd4d8f3 100644
--- a/crates/beads-core/src/error.rs
+++ b/crates/beads-core/src/error.rs
@@ -12,7 +12,7 @@ pub enum BeadsError {
     UlidDecode(#[from] ulid::DecodeError),
     #[error("beads repository already initialized")]
     AlreadyInitialized,
-    #[error("beads repository not found")]
+    #[error("beads repository not found. Run 'beads init --prefix <prefix>' to create one.")]
     RepoNotFound,
     #[error("missing repository configuration: {0}")]
     MissingConfig(&'static str),
diff --git a/crates/beads/src/commands/issue/create.rs b/crates/beads/src/commands/issue/create.rs
index c8cfb9c..8c7552b 100644
--- a/crates/beads/src/commands/issue/create.rs
+++ b/crates/beads/src/commands/issue/create.rs
@@ -43,7 +43,7 @@ pub fn run(
     let (json_kind, json_priority, json_desc): (Option<String>, Option<u32>, Option<String>) =
         if let Some(data_str) = &data {
             let parsed = serde_json::from_str::<serde_json::Value>(data_str)
-                .map_err(|e| anyhow!("Invalid JSON data: {}", e))?;
+                .map_err(|e| anyhow!("Invalid JSON data: {}\n\nExpected format: '{{\"description\":\"...\",\"priority\":1,\"kind\":\"bug\"}}'", e))?;
             let kind = parsed.get("kind").and_then(|v| v.as_str()).map(|s| s.to_string());
             let priority = parsed.get("priority").and_then(|v| v.as_u64()).map(|p| p as u32);
             let desc = parsed
diff --git a/crates/beads/src/commands/issue/update.rs b/crates/beads/src/commands/issue/update.rs
index dea5957..60f592d 100644
--- a/crates/beads/src/commands/issue/update.rs
+++ b/crates/beads/src/commands/issue/update.rs
@@ -47,7 +47,7 @@ pub fn run(
     // Parse JSON --data if provided
     if let Some(data_str) = data {
         let json = serde_json::from_str::<serde_json::Value>(&data_str)
-            .map_err(|e| anyhow!("Invalid JSON data: {}", e))?;
+            .map_err(|e| anyhow!("Invalid JSON data: {}\n\nExpected format: '{{\"description\":\"...\",\"priority\":1,\"status\":\"closed\"}}'", e))?;
 
         // Apply JSON values only if not already set by flags
         if update.description.is_none() {
@@ -82,7 +82,10 @@ pub fn run(
     let has_label_operations = add_label.is_some() || remove_label.is_some();
 
     if !has_field_updates && !has_label_operations {
-        return Err(anyhow!("No updates specified"));
+        return Err(anyhow!(
+            "No updates specified.\n\nAvailable options:\n  --title <TITLE>\n  --description <DESCRIPTION>\n  --kind <KIND>\n  --priority <PRIORITY>\n  --status <STATUS>\n  --add-label <LABELS>\n  --remove-label <LABELS>\n  --data <JSON>\n\nExample: beads issue update {} --status closed",
+            id
+        ));
     }
 
     // Apply field updates if any
```
</details></tool-use>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:57:48Z)**_

<think><details><summary>Thought Process</summary>
Perfect! Now I can see what was implemented. Let me analyze:

## What Was Implemented (Past Work)

### Iteration 1 (commits 8b60dc3, df6effa, 8409eec):
- Custom ValueEnum implementation for Priority, Kind, Status
- Case-insensitive matching
- Numeric aliases for priority (0-3)
- Migration to typed enums in CLI args
- Deleted cli/errors.rs
- Hidden deprecated commands

### Iteration 2 (commit 21a1e01):
- Improved "No updates specified" error with all options listed
- Improved "Invalid JSON data" error with expected format hints
- Improved "Repository not found" error with suggestion

## What Still Needs to Be Done (Next Steps)

Based on our evolvable error system plan, the current implementation still has the problems we identified:
1. ❌ Error messages still hardcoded as strings in command handlers
2. ❌ Duplicate formatting (JSON error duplicated in create.rs and update.rs)
3. ❌ Can't add error codes or help URLs
4. ❌ Can't change format globally
5. ❌ No structured metadata

So the next step is to implement the evolvable error system we planned in `docs/work/2026-01-31-evolvable-error-system.md`.

Let me write a concise code plan for implementing this.
</details></think>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:58:56Z)**_

<tool-use data-tool-type="write" data-tool-name="Write"><details>
<summary>Tool use: **Write**</summary>

```md
# Evolvable Error System - Code Plan

## What Was Already Implemented

Based on git commits 8b60dc3 → 21a1e01:

### ✅ Iteration 1: Enum Validation (commits 8b60dc3, df6effa, 8409eec)
- Custom `ValueEnum` for Priority, Kind, Status with case-insensitive matching
- Numeric aliases (0-3) for priority
- Migrated CLI args to typed enums
- Deleted `cli/errors.rs` (manual validation helpers)
- Hidden deprecated commands

### ✅ Iteration 2: Improved Messages (commit 21a1e01)
- "No updates specified" → lists all options + example
- "Invalid JSON data" → shows expected format
- "Repository not found" → suggests `beads init`

### ❌ Still Has Problems
\```rust
// create.rs:46 and update.rs:50 (DUPLICATED!)
.map_err(|e| anyhow!("Invalid JSON data: {}\n\nExpected format: '{{...}}'", e))?

// update.rs:85-88 (HARDCODED, CAN'T EVOLVE)
anyhow!("No updates specified.\n\nAvailable options:\n  --title <TITLE>...")
\```

**Issues:**
- ❌ Strings scattered across 8+ command files
- ❌ Duplicate formatting
- ❌ Can't add error codes later
- ❌ Can't change format globally
- ❌ No structured metadata

---

## Code Plan: Evolvable Error Refactor

### Phase 1: Structured Error Types

#### File 1: `crates/beads-core/src/error.rs`

**Add structured variants:**

\```rust
#[derive(Debug, Error)]
pub enum BeadsError {
    // === Existing (keep as-is) ===
    #[error("io error: {0}")]
    Io(#[from] std::io::Error),
    #[error("database error: {0}")]
    Db(#[from] rusqlite::Error),
    #[error("serialization error: {0}")]
    Serde(#[from] serde_json::Error),
    #[error("ulid decode error: {0}")]
    UlidDecode(#[from] ulid::DecodeError),
    #[error("beads repository already initialized")]
    AlreadyInitialized,
    #[error("beads repository not found")]  // ← Remove inline hint
    RepoNotFound,
    #[error("missing repository configuration: {0}")]
    MissingConfig(&'static str),
    #[error("blob not found: {0}")]
    BlobNotFound(String),
    #[error("invalid hash: {0}")]
    InvalidHash(String),
    #[error("{0}")]
    Custom(String),

    // === NEW: Structured CLI Errors ===
    #[error("update requires at least one field")]  // ← Keep simple message
    EmptyUpdate {
        entity_id: String,
        available_fields: Vec<&'static str>,
    },

    #[error("invalid JSON data")]  // ← Keep simple message
    InvalidJsonData {
        source: serde_json::Error,
        expected_fields: Vec<&'static str>,
        context: &'static str,  // "create" or "update"
    },

    #[error("required field missing: {field}")]
    MissingRequiredField {
        field: &'static str,
    },

    #[error("invalid document format")]
    InvalidDocFormat {
        provided: String,
    },
}
\```

**Add builder methods:**

\```rust
impl BeadsError {
    /// Create EmptyUpdate error for issue update
    pub fn empty_update(entity_id: impl Into<String>) -> Self {
        Self::EmptyUpdate {
            entity_id: entity_id.into(),
            available_fields: vec![
                "--title",
                "--description",
                "--kind",
                "--priority",
                "--status",
                "--add-label",
                "--remove-label",
                "--data",
            ],
        }
    }

    /// Create InvalidJsonData error for create command
    pub fn invalid_json_for_create(source: serde_json::Error) -> Self {
        Self::InvalidJsonData {
            source,
            expected_fields: vec!["description", "priority", "kind"],
            context: "create",
        }
    }

    /// Create InvalidJsonData error for update command
    pub fn invalid_json_for_update(source: serde_json::Error) -> Self {
        Self::InvalidJsonData {
            source,
            expected_fields: vec!["description", "priority", "status", "kind"],
            context: "update",
        }
    }

    /// Create MissingRequiredField error
    pub fn missing_field(field: &'static str) -> Self {
        Self::MissingRequiredField { field }
    }

    /// Create InvalidDocFormat error
    pub fn invalid_doc_format(provided: impl Into<String>) -> Self {
        Self::InvalidDocFormat {
            provided: provided.into(),
        }
    }
}
\```

**Add custom Display implementation:**

\```rust
use std::fmt::{self, Display};

impl Display for BeadsError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            // System errors - use default from wrapped error
            Self::Io(e) => write!(f, "io error: {}", e),
            Self::Db(e) => write!(f, "database error: {}", e),
            Self::Serde(e) => write!(f, "serialization error: {}", e),
            Self::UlidDecode(e) => write!(f, "ulid decode error: {}", e),

            // Repository errors
            Self::AlreadyInitialized => {
                write!(f, "beads repository already initialized")
            }
            Self::RepoNotFound => {
                write!(f, "beads repository not found")?;
                write!(f, "\n\nRun 'beads init --prefix <prefix>' to create one")
            }
            Self::MissingConfig(key) => {
                write!(f, "missing repository configuration: {}", key)
            }

            // Structured CLI errors - CENTRAL FORMATTING
            Self::EmptyUpdate { entity_id, available_fields } => {
                write!(f, "No updates specified for {}.\n\n", entity_id)?;
                write!(f, "Available options:\n")?;
                for field in available_fields {
                    write!(f, "  {}\n", field)?;
                }
                write!(f, "\nExample: beads issue update {} --status closed", entity_id)
            }

            Self::InvalidJsonData { source, expected_fields, context } => {
                write!(f, "Invalid JSON data: {}\n\n", source)?;
                write!(f, "Expected format for {}:\n{{\n", context)?;
                for field in expected_fields {
                    write!(f, "  \"{}\": <value>,\n", field)?;
                }
                write!(f, "}}")
            }

            Self::MissingRequiredField { field } => {
                write!(f, "{} is required and cannot be empty", field)
            }

            Self::InvalidDocFormat { provided } => {
                write!(f, "Invalid doc format '{}'. Expected 'name:path'\n\n", provided)?;
                write!(f, "Example: --doc readme:./README.md")
            }

            // Resource errors
            Self::BlobNotFound(hash) => write!(f, "blob not found: {}", hash),
            Self::InvalidHash(hash) => write!(f, "invalid hash: {}", hash),

            // Fallback
            Self::Custom(msg) => write!(f, "{}", msg),
        }
    }
}
\```

**Estimated changes:** ~100 lines added to `error.rs`

---

#### File 2: `crates/beads/src/commands/issue/create.rs`

**Line 39: Empty title validation**

\```rust
// BEFORE
if title.trim().is_empty() {
    return Err(anyhow!("Title is required and cannot be empty"));
}

// AFTER
if title.trim().is_empty() {
    return Err(BeadsError::missing_field("title").into());
}
\```

**Line 46: Invalid JSON**

\```rust
// BEFORE
let parsed = serde_json::from_str::<serde_json::Value>(data_str)
    .map_err(|e| anyhow!("Invalid JSON data: {}\n\nExpected format: '{{\"description\":\"...\",\"priority\":1,\"kind\":\"bug\"}}'", e))?;

// AFTER
let parsed = serde_json::from_str::<serde_json::Value>(data_str)
    .map_err(BeadsError::invalid_json_for_create)?;
\```

**Line 107: Invalid doc format**

\```rust
// BEFORE
if parts.len() != 2 {
    eprintln!("Invalid doc format '{}'. Expected 'name:path'", doc_spec);
    continue;
}

// AFTER
if parts.len() != 2 {
    eprintln!("{}", BeadsError::invalid_doc_format(doc_spec));
    continue;
}
\```

**Add import:**
\```rust
use beads_core::BeadsError;  // Add to existing imports
\```

**Estimated changes:** 3 lines modified, 1 import added

---

#### File 3: `crates/beads/src/commands/issue/update.rs`

**Line 50: Invalid JSON**

\```rust
// BEFORE
let json = serde_json::from_str::<serde_json::Value>(&data_str)
    .map_err(|e| anyhow!("Invalid JSON data: {}\n\nExpected format: '{{\"description\":\"...\",\"priority\":1,\"status\":\"closed\"}}'", e))?;

// AFTER
let json = serde_json::from_str::<serde_json::Value>(&data_str)
    .map_err(BeadsError::invalid_json_for_update)?;
\```

**Line 85-88: Empty update**

\```rust
// BEFORE
if !has_field_updates && !has_label_operations {
    return Err(anyhow!(
        "No updates specified.\n\nAvailable options:\n  --title <TITLE>\n  --description <DESCRIPTION>\n  --kind <KIND>\n  --priority <PRIORITY>\n  --status <STATUS>\n  --add-label <LABELS>\n  --remove-label <LABELS>\n  --data <JSON>\n\nExample: beads issue update {} --status closed",
        id
    ));
}

// AFTER
if !has_field_updates && !has_label_operations {
    return Err(BeadsError::empty_update(id).into());
}
\```

**Add import:**
\```rust
use beads_core::BeadsError;  // Add to existing imports
\```

**Estimated changes:** 2 blocks simplified (12 lines → 2 lines), 1 import added

---

#### File 4: `crates/beads/src/commands/create.rs` (deprecated)

**Line ~40: Invalid JSON**

\```rust
// BEFORE
let data = serde_json::from_str::<serde_json::Value>(&data_str)
    .map_err(|e| anyhow!("Invalid JSON data: {}", e))?;

// AFTER
let data = serde_json::from_str::<serde_json::Value>(&data_str)
    .map_err(BeadsError::invalid_json_for_create)?;
\```

**Add import:**
\```rust
use beads_core::BeadsError;
\```

**Estimated changes:** 1 line modified, 1 import added

---

#### File 5: `crates/beads/src/commands/update.rs` (deprecated)

**Similar to File 4:** Replace JSON parsing error

**Estimated changes:** 1 line modified, 1 import added

---

### Phase 1 Summary

| File | Lines Changed | Type |
|------|---------------|------|
| `beads-core/src/error.rs` | +100 | Add variants, builders, Display impl |
| `beads/src/commands/issue/create.rs` | -10, +3 | Replace anyhow! with builders |
| `beads/src/commands/issue/update.rs` | -14, +2 | Replace anyhow! with builders |
| `beads/src/commands/create.rs` | -1, +1 | Replace anyhow! |
| `beads/src/commands/update.rs` | -1, +1 | Replace anyhow! |

**Total:** ~100 lines added, ~26 lines removed → Net +74 lines

**Benefits:**
✅ Zero hardcoded multi-line error strings
✅ Single source of truth for formatting
✅ No duplicate error messages
✅ Easy to add error codes later (Phase 2)

---

## Testing Strategy

### Unit Tests

Add to `crates/beads-core/src/error.rs`:

\```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_empty_update_formatting() {
        let err = BeadsError::empty_update("bd-015");
        let msg = err.to_string();

        assert!(msg.contains("No updates specified"));
        assert!(msg.contains("bd-015"));
        assert!(msg.contains("--title"));
        assert!(msg.contains("--status"));
        assert!(msg.contains("Example:"));
    }

    #[test]
    fn test_invalid_json_for_create() {
        let json_err = serde_json::from_str::<serde_json::Value>("invalid")
            .unwrap_err();
        let err = BeadsError::invalid_json_for_create(json_err);
        let msg = err.to_string();

        assert!(msg.contains("Invalid JSON"));
        assert!(msg.contains("create"));
        assert!(msg.contains("description"));
        assert!(msg.contains("priority"));
    }

    #[test]
    fn test_missing_field() {
        let err = BeadsError::missing_field("title");
        let msg = err.to_string();

        assert!(msg.contains("title"));
        assert!(msg.contains("required"));
        assert!(msg.contains("cannot be empty"));
    }

    #[test]
    fn test_repo_not_found_includes_hint() {
        let err = BeadsError::RepoNotFound;
        let msg = err.to_string();

        assert!(msg.contains("beads repository not found"));
        assert!(msg.contains("beads init"));
        assert!(msg.contains("--prefix"));
    }
}
\```

### Manual Testing

\```bash
# Build
cargo build

# Test error messages
beads issue update bd-001  # → Should show "No updates specified" with all options
beads issue create --title "test" --data "invalid"  # → Should show JSON format hint
beads issue create --title ""  # → Should show "title is required"
cd /tmp && beads issue list  # → Should suggest beads init

# Verify existing functionality still works
beads issue create --title "test" --priority HIGH
beads issue update bd-001 --status closed
\```

---

## Migration Steps

1. **Modify `error.rs`** (single file)
   - Add new variants
   - Add builder methods
   - Add Display impl
   - Add tests
   - Verify: `cargo build`

2. **Update `issue/create.rs`** (3 small changes)
   - Replace title validation
   - Replace JSON error
   - Replace doc format error
   - Verify: `cargo build && cargo test`

3. **Update `issue/update.rs`** (2 small changes)
   - Replace JSON error
   - Replace empty update error
   - Verify: `cargo build && cargo test`

4. **Update deprecated commands** (optional, 2 files)
   - Replace JSON errors in `create.rs` and `update.rs`
   - Verify: `cargo build`

5. **Manual testing** (all scenarios)
   - Test each error message type
   - Verify output matches expected format

6. **Commit**
   \```bash
   git add crates/beads-core/src/error.rs \
           crates/beads/src/commands/issue/create.rs \
           crates/beads/src/commands/issue/update.rs
   git commit -m "refactor(errors): implement evolvable error system with structured types"
   \```

---

## Phase 2: Error Codes (Optional Future Work)

After Phase 1 is stable, add error codes:

\```rust
impl BeadsError {
    pub fn code(&self) -> &'static str {
        match self {
            Self::EmptyUpdate { .. } => "E200",
            Self::InvalidJsonData { .. } => "E201",
            Self::MissingRequiredField { .. } => "E202",
            // ...
        }
    }

    pub fn help_url(&self) -> Option<String> {
        Some(format!("https://docs.beads.dev/errors/{}", self.code()))
    }
}

// Update Display to include code
impl Display for BeadsError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "error[{}]: ", self.code())?;
        // ... existing formatting ...
    }
}
\```

**Output:**
\```
error[E200]: No updates specified for bd-015.

Available options:
  --title
  --status

Example: beads issue update bd-015 --status closed

For more info: https://docs.beads.dev/errors/E200
\```

---

## Success Criteria

✅ All error messages formatted via `Display` trait in `error.rs`
✅ Zero `anyhow!()` with multi-line hardcoded strings in commands
✅ CLI validation errors use structured `BeadsError` variants
✅ Can change error format globally by editing one file
✅ Unit tests verify error message content
✅ Manual testing shows same user-visible output
✅ No behavioral changes to functionality

---

## Timeline

- **Phase 1 implementation:** 1-2 hours
- **Testing:** 30 minutes
- **Total:** ~2.5 hours

---

## Files to Modify (Phase 1)

1. `crates/beads-core/src/error.rs` (major: +100 lines)
2. `crates/beads/src/commands/issue/create.rs` (minor: 3 changes)
3. `crates/beads/src/commands/issue/update.rs` (minor: 2 changes)
4. `crates/beads/src/commands/create.rs` (minor: 1 change, optional)
5. `crates/beads/src/commands/update.rs` (minor: 1 change, optional)

**Total files:** 3 required + 2 optional deprecated = 5 files

```
```
File created successfully at: /home/abhishek/Downloads/experiments/ai-tools/beadify/docs/work/2026-01-31-evolvable-errors-code-plan.md
```
</details></tool-use>

_**Agent (claude-sonnet-4-5-20250929 2026-01-31 06:58:59Z)**_

<think><details><summary>Thought Process</summary>
Good, I created the detailed code plan. Now the user is asking for a detailed code plan (which I just did) and a short summary. Let me provide both - the detailed plan is already written, now I'll extract a short summary from it.
</details></think>

_**Agent - sidechain (claude-sonnet-4-5-20250929 2026-01-31 06:59:10Z)**_

## Summary

Created detailed code plan at `docs/work/2026-01-31-evolvable-errors-code-plan.md`

### What Was Already Done (Git Commits Analysis)
✅ **Iteration 1:** ValueEnum validation, case-insensitive matching, numeric aliases
✅ **Iteration 2:** Improved error messages with hints

### Current Problem
❌ Error strings still hardcoded across 8+ files
❌ Duplicate formatting (JSON error in both create.rs + update.rs)
❌ Can't evolve (add codes, change format globally)

### Phase 1 Plan: Structured Errors

**Core change:** Separate error **data** from **presentation**

**1. Add to `error.rs` (~100 lines):**
   - New variants: `EmptyUpdate`, `InvalidJsonData`, `MissingRequiredField`, `InvalidDocFormat`
   - Builder methods: `empty_update()`, `invalid_json_for_create()`, etc.
   - Custom `Display` impl (all formatting in ONE place)

**2. Update command files (5 files, ~10 line changes each):**
   - Replace `anyhow!("hardcoded...")` → `BeadsError::builder_method()`
   - Example: `anyhow!("No updates...")` → `BeadsError::empty_update(id).into()`

**Result:**
- ✅ Zero hardcoded multi-line strings
- ✅ Change all formats by editing one file
- ✅ Ready for error codes (Phase 2)
- ✅ Net +74 lines, ~2 hours work

**Next:** Ready to implement Phase 1?

_**Agent - sidechain (2026-01-31 06:59:10Z)**_

[SUGGESTION MODE: Suggest what the user might naturally type next into Claude Code.]

FIRST: Look at the user's recent messages and original request.

Your job is to predict what THEY would type - not what you think they should do.

THE TEST: Would they think "I was just about to type that"?

EXAMPLES:
User asked "fix the bug and run tests", bug is fixed → "run the tests"
After code written → "try it out"
Claude offers options → suggest the one the user would likely pick, based on conversation
Claude asks to continue → "yes" or "go ahead"
Task complete, obvious follow-up → "commit this" or "push it"
After error or misunderstanding → silence (let them assess/correct)

Be specific: "run the tests" beats "continue".

NEVER SUGGEST:
- Evaluative ("looks good", "thanks")
- Questions ("what about...?")
- Claude-voice ("Let me...", "I'll...", "Here's...")
- New ideas they didn't ask about
- Multiple sentences

Stay silent if the next step isn't obvious from what the user said.

Format: 2-12 words, match the user's style. Or nothing.

Reply with ONLY the suggestion, no quotes or explanation.
