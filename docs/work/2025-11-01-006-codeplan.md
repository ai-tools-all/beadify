Excellent. This three-crate workspace approach is a fantastic evolution of the plan. It strikes the perfect balance between strong architectural separation and pragmatic project management. It keeps the core logic pure and testable, the CLI thin and focused, and the utility completely independent.

Let's merge this structure with the best parts of the initial multi-crate plan (like centralized workspace dependencies and a dedicated tracing crate) to create the definitive, final code plan.

---

### Final Merged Code Plan: The Best of Both Worlds

This plan adopts your preferred three-crate structure (`beads`, `beads-core`, `beads-merge-driver`) and enhances it by adding a fourth, small utility crate (`beads-tracing`) and using a workspace manifest (`Cargo.toml`) to manage shared dependencies, ensuring consistency and reducing boilerplate.

#### Workspace Structure

```text
beads-project/
├── Cargo.toml               # The Workspace root (defines all members and dependencies)
├── .gitignore
├── crates/
│   │
│   ├── beads/               # Crate 1: The CLI binary
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── main.rs
│   │       └── commands/
│   │
│   ├── beads-core/          # Crate 2: The Core logic library
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── model.rs
│   │       ├── error.rs
│   │       ├── repo.rs
│   │       ├── db.rs
│   │       └── log.rs
│   │
│   ├── beads-merge-driver/  # Crate 3: The Merge driver binary
│   │   ├── Cargo.toml
│   │   └── src/main.rs
│   │
│   └── beads-tracing/       # Crate 4: The Tracing setup utility
│       ├── Cargo.toml
│       └── src/lib.rs
│
└── README.md
```

#### Project Setup: The Workspace Root

**`./Cargo.toml`**

This is the single source of truth for all dependencies. Each crate will reference dependencies from this workspace, ensuring version consistency.

```toml
[workspace]
members = [
    "crates/beads",
    "crates/beads-core",
    "crates/beads-merge-driver",
    "crates/beads-tracing",
]
resolver = "2"

[workspace.package]
version = "0.1.0"
edition = "2021" # Update to "2024" when stable
authors = ["Your Name <you@example.com>"]

# All dependencies for the entire project are defined here
[workspace.dependencies]
# CLI
clap = { version = "4.5", features = ["derive"] }
anyhow = "1.0"
thiserror = "1.0"

# Data & Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
chrono = "0.4"
ulid = "1.1"

# Database
rusqlite = { version = "0.31", features = ["bundled"] }

# Tracing & Logging
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

# Workspace Crates (for inter-crate dependencies)
beads-core = { path = "crates/beads-core" }
beads-tracing = { path = "crates/beads-tracing" }
```

---

### Crate 1: `beads-tracing` (Utility Library)

A tiny, reusable crate for initializing the logger/tracer.

**`crates/beads-tracing/Cargo.toml`**
```toml
[package]
name = "beads-tracing"
version.workspace = true
edition.workspace = true

[dependencies]
tracing.workspace = true
tracing-subscriber.workspace = true
```

**`crates/beads-tracing/src/lib.rs`**
```rust
use tracing_subscriber::{EnvFilter, FmtSubscriber};

/// Initializes the tracing subscriber for consistent logging.
/// Call this at the start of `main()` in any binary crate.
/// Users can control log level via RUST_LOG env var (e.g., RUST_LOG=debug).
pub fn init() {
    let subscriber = FmtSubscriber::builder()
        .with_env_filter(EnvFilter::from_default_env())
        .with_writer(std::io::stderr)
        .finish();
    tracing::subscriber::set_global_default(subscriber)
        .expect("Failed to set global tracing subscriber");
}
```

---

### Crate 2: `beads-core` (The Core Logic Library)

This is the heart of the application, containing all business logic.

**`crates/beads-core/Cargo.toml`**
```toml
[package]
name = "beads-core"
version.workspace = true
edition.workspace = true

[dependencies]
# All dependencies are inherited from the workspace
rusqlite.workspace = true
serde.workspace = true
serde_json.workspace = true
ulid.workspace = true
chrono.workspace = true
thiserror.workspace = true
```

**`crates/beads-core/src/lib.rs`**
This defines the clean, high-level API for the CLI to consume.
```rust
// 1. Declare all internal implementation modules
mod model;
mod error;
mod repo;
mod db;
mod log;

// 2. Re-export the most important types for easy access by consumers
pub use error::{BeadsError, Result};
pub use model::{Event, EventData, Issue, OpKind};
pub use repo::{BeadsRepo, find_repo, BEADS_DIR}; // Expose constants too

// --- Phase 1: High-Level API Functions ---

/// Initializes a new beads repository in the given directory.
pub fn init_repo(path: &std::path::Path) -> Result<BeadsRepo> {
    let repo = BeadsRepo::new(path.to_path_buf());
    if repo.beads_dir.exists() {
        return Err(BeadsError::AlreadyInitialized);
    }
    std::fs::create_dir(&repo.beads_dir)?;
    std::fs::File::create(&repo.log_path)?;
    let conn = repo.open_db()?;
    db::create_schema(&conn)?;
    Ok(repo)
}

/// Creates a new issue, writing to the log and updating the cache.
pub fn create_issue(repo: &BeadsRepo, title: &str, kind: &str, priority: u32) -> Result<Event> {
    let conn = repo.open_db()?;
    let mut generator = log::get_monotonic_generator(&conn)?;
    let issue_id = ulid::Ulid::new().to_string(); // Placeholder ID logic
    let op = OpKind::Create;
    let data = EventData::Create {
        title: title.to_string(),
        kind: kind.to_string(),
        priority,
    };
    log::write_event(repo, &conn, &mut generator, op, issue_id, data)
}

/// Retrieves all issues directly from the database cache.
pub fn get_all_issues(repo: &BeadsRepo) -> Result<Vec<Issue>> {
    let conn = repo.open_db()?;
    db::get_all_issues(&conn)
}

/// Rebuilds the entire database from the event log.
pub fn run_full_sync(repo: &BeadsRepo) -> Result<usize> {
    std::fs::remove_file(&repo.db_path)?;
    let conn = repo.open_db()?;
    db::create_schema(&conn)?;
    let (count, new_offset, new_event_id) = log::apply_all_events(&conn, repo)?;
    let tx = conn.transaction()?;
    db::set_meta(&tx, "last_processed_offset", &new_offset.to_string())?;
    db::set_meta(&tx, "last_event_id", &new_event_id)?;
    tx.commit()?;
    Ok(count)
}

// NOTE: We need to create an `apply_all_events` in `log.rs` for this.
```

**(Other `beads-core` files like `model.rs`, `db.rs`, etc., would contain the same code as the previous plans, now organized as private modules within this crate.)**

---

### Crate 3: `beads` (The CLI Binary)

This crate is a thin wrapper that handles command-line parsing and printing.

**`crates/beads/Cargo.toml`**
```toml
[package]
name = "beads"
version.workspace = true
edition.workspace = true

[[bin]]
name = "beads"
path = "src/main.rs"

[dependencies]
clap.workspace = true
anyhow.workspace = true
# ...and our workspace crates!
beads-core = { workspace = true }
beads-tracing = { workspace = true }
```

**`crates/beads/src/main.rs`**
```rust
use anyhow::Result;
use clap::{Parser, Subcommand};
// Use our own crates!
use beads_core::repo::find_repo;
use beads_tracing::init as init_tracing;

mod commands;

// ... (Clap structs `Cli` and `Commands` remain identical to previous plan) ...
#[derive(Parser)]
#[command(author, version, about, long_about = None)]
#[command(propagate_version = true)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Initialize a new beads repository
    Init,
    /// Create a new issue
    Create {
        #[arg(short, long)] title: String,
        #[arg(short, long, default_value = "task")] kind: String,
        #[arg(short, long, default_value_t = 2)] priority: u32,
    },
    /// List all issues
    List,
    /// Apply new events from the log to the local database
    Sync {
        #[arg(long)] full: bool,
    },
}


fn main() -> Result<()> {
    init_tracing(); // Set up logging immediately

    let cli = Cli::parse();
    let repo = if !matches!(cli.command, Commands::Init) {
        Some(find_repo()?)
    } else {
        None
    };

    match &cli.command {
        Commands::Init => commands::init::run()?,
        Commands::Create { title, kind, priority } => {
            commands::create::run(repo.unwrap(), title, kind, *priority)?
        },
        Commands::List => commands::list::run(repo.unwrap())?,
        Commands::Sync { full } => commands::sync::run(repo.unwrap(), *full)?,
    }

    Ok(())
}
```

**`crates/beads/src/commands/create.rs`**
(Example of a thin command wrapper)
```rust
use beads_core::{BeadsRepo, Result};

pub fn run(repo: BeadsRepo, title: &str, kind: &str, priority: u32) -> Result<()> {
    // All logic is delegated to the core library
    let event = beads_core::create_issue(&repo, title, kind, priority)?;
    // The CLI's only job is to provide user feedback
    println!("Created issue {}", event.id);
    Ok(())
}
```
**(The other command files, `init.rs`, `list.rs`, `sync.rs`, would be similarly thin wrappers around their corresponding `beads_core` functions.)**

---

### Crate 4: `beads-merge-driver` (The Git Utility)

A standalone binary with no dependencies on `beads-core`.

**`crates/beads-merge-driver/Cargo.toml`**
```toml
[package]
name = "beads-merge-driver"
version.workspace = true
edition.workspace = true

# No dependencies from the workspace are needed
[dependencies]
```

**`crates/beads-merge-driver/src/main.rs`**
(This is the robust version that correctly implements the 3-way line union.)
```rust
use std::collections::HashSet;
use std::env;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::process;

/// Reads all lines from a file path into a set to ensure uniqueness.
fn read_lines_to_set(path: &str, set: &mut HashSet<String>) -> io::Result<()> {
    let file = File::open(path)?;
    let reader = BufReader::new(file);
    for line in reader.lines() {
        let line = line?;
        if !line.trim().is_empty() {
            set.insert(line);
        }
    }
    Ok(())
}

fn main() {
    let args: Vec<String> = env::args().collect();
    // Git provides 3 file paths: base, local (current), remote (other)
    if args.len() != 4 {
        eprintln!("Usage: beads-merge-driver <base> <local> <remote>");
        process::exit(1);
    }

    let mut line_set = HashSet::new();

    // Read all unique lines from all three versions of the file
    for path in [&args[1], &args[2], &args[3]] {
        if let Err(e) = read_lines_to_set(path, &mut line_set) {
            eprintln!("Error reading file '{}': {}", path, e);
            // Don't exit on error for a missing base file, it's a common case
            if !path.contains("tmp_base_") {
                 process::exit(1);
            }
        }
    }

    // Sort the lines to ensure the merge is deterministic. ULIDs are sortable.
    let mut sorted_lines: Vec<String> = line_set.into_iter().collect();
    sorted_lines.sort();

    // Write the resulting merged content to stdout.
    // Git is configured to capture this output and write it to the final merged file.
    for line in sorted_lines {
        println!("{}", line);
    }
}
```