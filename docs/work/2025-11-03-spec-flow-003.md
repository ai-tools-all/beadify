Here is the updated specification for "Beads" (File 2), implementing your requested changes.

The core modifications are:

1.  **True Offline-First Writes:** Workflows 4.3 and 4.4 no longer run `sync` *before* a write. All mutations are written to the local log and cache instantly.
2.  **`beads sync` Re-defined:** This command is now the explicit step for reconciling with the remote (both pulling and pushing).
3.  **Merge Driver Prominence:** Section 5.1 has been rewritten to highlight the merge driver as the highest-risk component and to clarify its "set union" logic.

-----

## 1\. Vision & Core Philosophy

This document specifies **Beads**, a dependency-aware issue tracker built on a **Git-native, event-sourcing (ES) architecture**.

The core philosophy is:

  * **The Log is the Truth:** The single source of truth is a single, append-only event log, `events.jsonl`. This file is committed to Git and is the definitive history of all issues.
  * **The DB is a Cache:** The local `beads.db` (SQLite) is an ephemeral, queryable, high-speed **materialized view** of the log. It is in `.gitignore`.
  * **Offline & Fast (Local-First):** The system is designed to be fully operational offline. All reads (`list`, `show`) and **all writes** (`create`, `update`) are instantaneous, interacting only with the local cache and log. Syncing with the remote is an explicit, separate action.
  * **Zero Merge Conflicts:** The event-sourcing model transforms all operations into append-only writes. A custom Git merge driver handles conflicts at the file level, and the LWW (Last-Write-Wins) sync logic handles them at the data level.
  * **Human-Centric Editing:** All interaction with the log is abstracted by the `beads` CLI, providing a simple, file-based editing experience for humans without sacrificing system integrity.

-----

## 2\. Core Components

### 2.1. `/.beads/events.jsonl` (The Source of Truth)

This is the only file that should be tracked by Git. It is a single, append-only file where each line is a JSON object representing one "event" (a change) in the system.

  * **Format:** Newline-delimited JSON (NDJSON).
  * **Properties:** Immutable, append-only.
  * **Conflict-free:** Git merge conflicts are resolved by a custom merge driver (see Section 5.1).

### 2.2. `/.beads/beads.db` (The Local Cache)

This is a standard SQLite database that represents the *current state* of the world.

  * **Format:** SQLite 3 file.
  * **Properties:** Ephemeral, local-only.
  * **Rule:** This file **MUST** be in `.gitignore`. It can be deleted and fully rebuilt from `events.jsonl` at any time.
  * **Purpose:** Provides fast, complex queries (e.g., `beads ready`, `beads search`) without replaying the entire log.

-----

## 3\. Data Models

### 3.1. The Event Model (in `events.jsonl`)

Every event in the log follows this JSON schema:

```json
{
  "event_id": "string", // ULID (uuidv7) generated at append time, totally orders events
  "ts": "string",   // ISO 8601 UTC timestamp (e.g., "2025-10-31T12:05:30.123Z")
  "op": "string",   // The operation type.
  "id": "string",   // The primary issue ID (e.d., "bd-1").
  "actor": "string",// Identifier for the user/agent (e.g., "user@host").
  "data": "object"  // The payload for the operation.
}
```

#### Event Operations (`op`) and Payloads (`data`):

  * **`create`**: A new issue is created.
      * `data`: `{ "title": "...", "type": "...", "priority": 2, ... }`
      * *Note:* The full Markdown spec (description, design) is included here as text.
  * **`update`**: One or more fields on an issue are changed.
      * `data`: `{ "status": "in_progress", "assignee": "alice" }`
      * `data`: `{ "description": "New spec text...", "design": "New design..." }`
  * **`link`**: A dependency is added.
      * `data`: `{ "to_id": "bd-2", "type": "blocks" }` (This event on `bd-1` means "bd-1 blocks bd-2")
  * **`unlink`**: A dependency is removed.
      * `data`: `{ "to_id": "bd-2", "type": "blocks" }`
  * **`comment`**: A comment is added.
      * `data`: `{ "body": "I'm starting work on this." }`
  * **`archive`**: An issue is archived (soft delete).
      * `data`: `{ "archived": true }`

### 3.2. The State Model (in `beads.db`)

This is the materialized view. The schema is identical to your original proposal, designed for fast queries.

  * **`issues` table**: Stores the *current* state of every issue (id, title, description, design, status, priority, etc.).
  * **`dependencies` table**: Stores the *current* dependency graph (issue\_id, depends\_on\_id, type).
  * **`labels` table**: Stores the *current* labels (issue\_id, label).
  * **`comments` table**: Stores all comments (materialized from `comment` events).
  * **`_meta` table**: A private table for the sync mechanism.
      * `key` (TEXT): e.g., "last\_processed\_offset", "last\_event\_id"
      * `value` (TEXT): Offsets stored as decimal strings, ULIDs stored verbatim

-----

## 4\. Core Workflows

### 4.1. Workflow: First-Time Sync (Initial Clone)

**Goal:** A new user/agent clones the repo and needs to build their local cache.

1.  User runs `beads sync`.
2.  `beads` detects no `beads.db` file.
3.  It opens `events.jsonl` and reads the *entire file* into memory.
4.  It parses each event, sorts the collection by `event_id` (ascending ULID), and reduces them to derive the final state of every issue.
5.  It creates a new `beads.db` and performs bulk `INSERT`s to populate the `issues`, `dependencies`, `labels`, and `comments` tables.
6.  It records the byte offset immediately after the final event into the `_meta` table (`last_processed_offset`) and stores the highest `event_id` in `_meta(last_event_id)`.
7.  This process may take 5-30 seconds, but is only done *once*.

### 4.2. Workflow: Syncing with Remote (Pull & Push)

**Goal:** A user wants to pull remote changes and push their own local changes.

1.  User runs `beads sync`.
2.  **Step 1 (Pull):** `beads` internally runs `git pull` (or the equivalent) to fetch and merge the remote `events.jsonl`. This merge is handled by the custom merge driver (see 5.1).
3.  **Step 2 (Incremental Read):** `beads` opens `beads.db` and reads `last_processed_offset` and `last_event_id` from the `_meta` table.
4.  It opens `events.jsonl`, calls `seek(last_processed_offset)`, and streams every subsequent line into memory.
5.  **Step 3 (Reconcile):** It parses the new events, sorts them by `event_id`, and validates that each ULID is strictly greater than the previously stored `last_event_id` (otherwise it triggers a recovery replay).
6.  It applies the sorted events as `UPDATE`s, `INSERT`s, or `DELETE`s to the *existing* `beads.db` using Last-Write-Wins semantics.
7.  **Step 4 (Update Meta):** It updates `_meta` with the byte offset immediately after the last processed event and persists the highest `event_id`.
8.  **Step 5 (Push):** `beads` internally runs `git push` to share the locally appended events (which are now part of the merged `events.jsonl`) with the remote.
9.  This process is the only one that requires a network connection.

### 4.3. Workflow: Creating/Updating an Issue (Local-First)

**Goal:** A user or AI agent closes an issue, *even when offline*.

1.  User runs `beads update bd-42 --status closed --actor "alice"`.
2.  `beads` requests a monotonic ULID from the local generator and produces a new event object:
    `{"event_id": "01J5...", "ts": "...", "op": "update", "id": "bd-42", "actor": "alice", "data": {"status": "closed"}}`
3.  **Step 1 (Write to Log):** Appends this single line to the *local* `events.jsonl`, ensuring the ULID is persisted, and notes the starting byte offset.
4.  **Step 2 (Update Cache):** Applies this *same event* to the *local* `beads.db` (e.g., `UPDATE issues SET status = 'closed' WHERE id = 'bd-42'`).
5.  **Step 3 (Update Meta):** Updates `_meta(last_processed_offset)` to the byte position immediately after the appended event and sets `_meta(last_event_id)` to the event's ULID.
6.  The CLI returns "OK" **immediately**. The user's system is now 100% consistent *locally*. The new event will be pushed on the next `beads sync`.

### 4.4. Workflow: Human Spec-Editing (Local-First)

**Goal:** A human wants to edit the Markdown plan for an epic, *even when offline*.

1.  User runs `beads spec edit bd-10`.
2.  **Step 1 (Read Cache):** `beads` queries the *local* `beads.db` for `bd-10`. (Fast).
3.  **Step 2 (Create Temp File):** It gets the `description`, `design`, etc., and formats them into a temporary Markdown file.
4.  **Step 3 (Launch Editor):** `beads` launches the user's `$EDITOR` and *waits*.
5.  **Step 4 (User Edits):** The user edits the file, saves, and closes the editor.
6.  **Step 5 (Parse Changes):** `beads` reads the *new* content from the temp file.
7.  **Step 6 (Write Event):** It generates a *new* `update` event and appends it to the *local* `events.jsonl`.
    `{"ts": "...", "op": "update", "id": "bd-10", "actor": "...", "data": {"description": "...", "design": "...", ...}}`
8.  **Step 7 (Update Cache):** `beads` applies this new event to the *local* `beads.db` and persists both the new byte offset and `last_event_id` in `_meta`.
9.  The CLI returns "OK" **immediately**.

-----

## 5\. Key Problems Solved

### 5.1. Git Merge Conflicts

  * **Problem:** Two users append events to `events.jsonl` on different branches. `git merge` will attempt a 3-way merge and fail, or worse, corrupt the file.
  * **Solution: Custom Git Merge Driver (Highest-Risk Component).**
      * This driver is the **most critical piece of custom tooling** in the architecture and must be prototyped and tested first.
      * We will provide a script and instruct users to set it up in `.gitattributes`:
        `*.jsonl merge=beadslog`
      * The `beadslog` merge driver (defined in `.git/config`) will be a program that implements a **line-based set union**.
      * **Logic:**
        1.  Read all lines from the `BASE`, `LOCAL`, and `REMOTE` file versions.
        2.  Create a `Set` of all lines to ensure uniqueness (deduplication).
        3.  Write all unique lines back to the file. The exact order is not critical, but appending `LOCAL` and `REMOTE` changes after `BASE` is logical.
      * **The Safety Net:** This driver's only job is to *prevent data loss*. It ensures all events from all branches are present in the merged file. The `beads sync` command (Section 4.2) provides the *actual* deterministic resolution by reading this merged file, sorting all new events by their `event_id`, and applying them in the correct LWW order.

### 5.2. Log Compaction (`events.jsonl` getting too big)

  * **Problem:** After 5 years, `events.jsonl` has 10 million lines. The initial sync for a new developer takes 20 minutes.
  * **Solution: `beads compact` Command.**
      * This is a **manual, privileged** command to be run periodically (e.g., once a year).
      * It reads the *entire* `events.jsonl` log.
      * It builds the final, current state of all issues.
      * It creates a *new* file, `events.snapshot.jsonl`.
      * For every **open** issue, it writes a single `create` event containing its full current state (title, status, spec text, etc.).
      * (Optional) For **closed** issues, it can either drop them or create a single `create` + `archive` event.
      * The user is then instructed to *replace* `events.jsonl` with this new, smaller snapshot file and commit it.
      * **WARNING:** This is a history-rewriting operation that may require a `git push --force` and coordination with all team members. (See Critique 3 for an alternative snapshot-file-based approach).

-----

## 6\. Updated CLI Command Reference

  * **Core Read Commands (Query Cache):**

      * `beads show <id>`
      * `beads list [filters...]`
      * `beads ready [filters...]`
      * `beads search <query>`
      * `beads stats`

  * **Core Write Commands (Append Log - Local-First & Fast):**

      * `beads create [title] [flags...]`
      * `beads update <id> [flags...]`
      * `beads close <id>`
      * `beads reopen <id>`
      * `beads comment <id> [message]`
      * `beads dep add <issue-id> <depends-on-id>`
      * `beads dep remove <issue-id> <depends-on-id>`
      * `beads label add <id> [label]`

  * **Human Editing Workflow (Local-First & Fast):**

      * `beads spec edit <id>`: Opens the spec for `<id>` in `$EDITOR`.

  * **Sync & Maintenance:**

      * `beads sync`: (Network) Reconciles local and remote state (pulls, merges via driver, applies new events, and pushes local events).
      * `beads sync --full`: (Slow) Deletes and fully rebuilds the local `beads.db`.
      * `beads compact`: (Privileged) Creates a new, compacted `events.jsonl` snapshot.
      * `beads init`: Sets up the `.beads` directory and instructs on the merge driver.