You're right, a multi-crate workspace is a much cleaner way to organize this. It enforces a strong separation of concerns, which is perfect for this architecture.

Here is a plan for organizing the project into a Cargo workspace with three distinct crates:

1.  **`beads-core` (Library):** Contains all core logic, data models, and database interactions. It knows nothing about the CLI or user input.
2.  **`beads` (Binary):** The main CLI. It depends on `beads-core` and `clap`. Its only job is to parse commands, call the core library, and print results.
3.  **`beads-merge-driver` (Binary):** The standalone Git merge driver utility. It has no dependencies on the other crates.

### Workspace Structure

Here's the new directory layout:

```text
beads-project/
├── Cargo.toml               # The Workspace root
├── .gitignore
├── crates/
│   │
│   ├── beads/               # Crate 1: The CLI binary
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── main.rs
│   │       └── commands/
│   │           ├── init.rs
│   │           ├── create.rs
│   │           ├── list.rs
│   │           └── sync.rs
│   │
│   ├── beads-core/          # Crate 2: The Core logic library
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs       # Exports all modules
│   │       ├── model.rs
│   │       ├── error.rs
│   │       ├── repo.rs
│   │       ├── db.rs
│   │       └── log.rs
│   │
│   └── beads-merge-driver/  # Crate 3: The Merge driver binary
│       ├── Cargo.toml
│       └── src/
│           └── main.rs
│
└── README.md
```

-----

### Crate 1: `beads-core` (The Library)

This crate is the heart of your application.

**`crates/beads-core/Cargo.toml`**

```toml
[package]
name = "beads-core"
version = "0.1.0"
edition = "2021"

[dependencies]
# All core logic dependencies live here
rusqlite = { version = "0.31", features = ["bundled"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
ulid = "1.1"
chrono = "0.4"
thiserror = "1.0"
```

**`crates/beads-core/src/lib.rs`**
This file defines the public API of your library.

```rust
// 1. Declare all modules
pub mod model;
pub mod error;
pub mod repo;
pub mod db;
pub mod log;

// 2. Re-export the most important types for easy access
pub use error::{BeadsError, Result};
pub use model::{Event, EventData, Issue, OpKind};
pub use repo::{BeadsRepo, find_repo};

// 3. This is the primary "entry point" for command logic.
//    We can create high-level functions that coordinate
//    the other modules.

use rusqlite::Connection;
use ulid::MonotonicGenerator;

/// High-level function to handle the "create" logic
pub fn create_issue(
    repo: &BeadsRepo, 
    title: &str, 
    kind: &str, 
    priority: u32
) -> Result<Event> {
    let conn = repo.open_db()?;
    let mut generator = log::get_monotonic_generator(&conn)?;

    // TODO: Issue ID generation logic
    let issue_id = ulid::Ulid::new().to_string();

    let op = OpKind::Create;
    let data = EventData::Create {
        title: title.to_string(),
        kind: kind.to_string(),
        priority,
    };

    // The log::write_event function performs the core
    // Write-Log -> Update-Cache -> Update-Meta workflow
    let event = log::write_event(&repo, &conn, &mut generator, op, issue_id.clone(), data)?;
    Ok(event)
}

/// High-level function to get all issues from the cache
pub fn get_all_issues(repo: &BeadsRepo) -> Result<Vec<Issue>> {
    let conn = repo.open_db()?;
    db::get_all_issues(&conn)
}

// ... other high-level functions like `run_full_sync`, `run_incremental_sync` ...
```

**`crates/beads-core/src/model.rs`**
(No change from the previous plan. Contains `Event`, `Issue`, etc.)

**`crates/beads-core/src/error.rs`**
(No change from the previous plan. Contains `BeadsError` enum.)

**`crates/beads-core/src/repo.rs`**
(No change from the previous plan. Contains `BeadsRepo` struct and `find_repo()`.)

**`crates/beads-core/src/db.rs`**
(No change from the previous plan. Contains `create_schema`, `apply_event`, `get_meta`, etc.)

**`crates/beads-core/src/log.rs`**
(No change from the previous plan. Contains `write_event` and `get_monotonic_generator`.)

-----

### Crate 2: `beads` (The CLI Binary)

This crate is now *much* simpler. It only knows how to parse arguments and call `beads-core`.

**`crates/beads/Cargo.toml`**

```toml
[package]
name = "beads"
version = "0.1.0"
edition = "2021"

[dependencies]
# It only needs clap and anyhow for the CLI layer...
clap = { version = "4.5", features = ["derive"] }
anyhow = "1.0"

# ...and our core logic!
beads-core = { path = "../beads-core" }
```

**`crates/beads/src/main.rs`**
(This file is almost identical to the previous plan's `main.rs`, but note the `use beads_core::...` line.)

```rust
use clap::{Parser, Subcommand};
use anyhow::Result;
use beads_core::repo::find_repo; // Use the core library

// Import our command handlers
mod commands;

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
#[command(propagate_version = true)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Initialize a new beads repository
    Init,
    
    /// Create a new issue
    Create {
        #[arg(short, long)]
        title: String,
        
        #[arg(short, long, default_value = "task")]
        kind: String,
        
        #[arg(short, long, default_value_t = 2)]
        priority: u32,
    },
    
    /// List all issues
    List,
    
    /// Apply new events from the log to the local database
    Sync {
        /// Force a full rebuild of the database from the event log
        #[arg(long)]
        full: bool,
    },
    // ... other commands
}

fn main() -> Result<()> {
    let cli = Cli::parse();
    
    let repo = if !matches!(cli.command, Commands::Init) {
        Some(find_repo()?) // This function comes from beads_core
    } else {
        None
    };

    match &cli.command {
        Commands::Init => {
            commands::init::run_init()?
        },
        Commands::Create { title, kind, priority } => {
            // Pass the repo object to the command handler
            commands::create::run_create(repo.unwrap(), title, kind, *priority)?
        },
        Commands::List => {
            commands::list::run_list(repo.unwrap())?
        },
        Commands::Sync { full } => {
            commands::sync::run_sync(repo.unwrap(), *full)?
        },
        // ...
    }

    Ok(())
}
```

**`crates/beads/src/commands/create.rs`**
(This file is now just a thin wrapper.)

```rust
use beads_core::{BeadsRepo, Result};

pub fn run_create(repo: BeadsRepo, title: &str, kind: &str, priority: u32) -> Result<()> {
    
    // All the complex logic is hidden inside this one call
    let event = beads_core::create_issue(&repo, title, kind, priority)?;

    // The CLI's only job is to print the result
    println!("Created issue {}", event.id);
    Ok(())
}
```

**`crates/beads/src/commands/list.rs`**
(Similarly, this just calls the core and prints.)

```rust
use beads_core::{BeadsRepo, Result};

pub fn run_list(repo: BeadsRepo) -> Result<()> {
    
    // Call the core library to get the data
    let issues = beads_core::get_all_issues(&repo)?;

    if issues.is_empty() {
        println!("No issues found. Try `beads create`!");
        return Ok(());
    }

    // Format the output
    println!("{:<12} | {:<8} | {:<40}", "ID", "STATUS", "TITLE");
    println!("{:-<12}-+-{:-<8}-+-{:-<40}", "", "", "");

    for issue in issues {
        let title = issue.title.chars().take(40).collect::<String>();
        println!("{:<12} | {:<8} | {:<40}", &issue.id[0..12], issue.status, title);
    }

    Ok(())
}
```

**`crates/beads/src/commands/init.rs`**
(This one is slightly different as it doesn't use a high-level function, but it still *uses* `beads-core` components.)

```rust
use beads_core::{Result, BeadsError, repo::{BeadsRepo, BEADS_DIR}, db};
use std::fs;
use std::env;

pub fn run_init() -> Result<()> {
    let current_dir = env::current_dir()?;
    let repo = BeadsRepo::new(current_dir); // from beads-core

    if repo.beads_dir.exists() {
        return Err(BeadsError::AlreadyInitialized); // from beads-core
    }

    fs::create_dir(&repo.beads_dir)?;
    fs::File::create(&repo.log_path)?;

    // Call db logic from beads-core
    let conn = repo.open_db()?;
    db::create_schema(&conn)?;

    println!("Initialized empty beads repository in {:?}", repo.beads_dir);
    // ...
    Ok(())
}
```

-----

### Crate 3: `beads-merge-driver` (The Utility)

This is a tiny, self-contained binary.

**`crates/beads-merge-driver/Cargo.toml`**

```toml
[package]
name = "beads-merge-driver"
version = "0.1.0"
edition = "2021"

[dependencies]
# No dependencies other than std!
```

**`crates/beads-merge-driver/src/main.rs`**

```rust
use std::collections::HashSet;
use std::env;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::process;

/// Reads all lines from a file path into a set
fn read_lines_to_set(path: &str, set: &mut HashSet<String>) -> io::Result<()> {
    let file = File::open(path)?;
    let reader = BufReader::new(file);
    for line in reader.lines() {
        set.insert(line?);
    }
    Ok(())
}

/// This program performs a 3-way line-based set union.
/// It is designed to be called by Git as:
/// `beads-merge-driver %O %A %B`
/// where %O=BASE, %A=LOCAL, %B=REMOTE
fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() != 4 {
        eprintln!("Usage: beads-merge-driver <base> <local> <remote>");
        process::exit(1);
    }
    
    let base_path = &args[1];
    let local_path = &args[2];
    let remote_path = &args[3];

    let mut line_set = HashSet::new();

    // Read all unique lines from all three files
    if let Err(e) = read_lines_to_set(base_path, &mut line_set) {
        eprintln!("Error reading base file: {}", e);
        process::exit(1);
    }
    if let Err(e) = read_lines_to_set(local_path, &mut line_set) {
        eprintln!("Error reading local file: {}", e);
        process::exit(1);
    }
    if let Err(e) = read_lines_to_set(remote_path, &mut line_set) {
        eprintln!("Error reading remote file: {}", e);
        process::exit(1);
    }

    // Write the resulting set to stdout
    // Git will capture this stdout and write it to the merged file
    for line in line_set {
        println!("{}", line);
    }
}
```